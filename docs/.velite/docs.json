[
	{
		"title": "Introduction",
		"description": "What is this?",
		"path": "index",
		"content": "<p>Formsnap takes the already incredible <a href=\"https://github.com/ciscoheat/sveltekit-superforms\">sveltekit-superforms</a> (winner of <a href=\"https://hack.sveltesociety.dev/winners\">Svelte Hack 2023</a> for best library), made by the brilliant <a href=\"https://github.com/ciscoheat\">Andreas Söderlund</a> and wraps it with components that make it simpler to use while making your forms accessible by default.</p>\n<h2>The Same Form, Two Ways</h2>\n<p>To showcase the value provided by Formsnap, let's take a look at a simple sign up form using only Superforms, and then using Superforms with Formsnap.</p>\n<h3>Superforms Only</h3>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport type { PageData } from \"./$types\";\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { signupFormSchema } from \"./schema\";\n\tlet { data } = $props();\n\n\tconst { form, errors, enhance, constraints } = superForm(data.form, {\n\t\tvalidators: zodClient(signupFormSchema),\n\t});\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:enhance>\n\t&#x3C;label for=\"name\">Name&#x3C;/label>\n\t&#x3C;input\n\t\tid=\"name\"\n\t\tname=\"name\"\n\t\taria-describedby={$errors.name ? \"name-error name-desc\" : \"name-desc\"}\n\t\taria-invalid={$errors.name ? \"true\" : undefined}\n\t\taria-required={$constraints.name?.required ? \"true\" : undefined}\n\t\tbind:value={$form.name}\n\t/>\n\t&#x3C;span id=\"name-desc\">Be sure to use your real name.&#x3C;/span>\n\t&#x3C;span id=\"name-error\" aria-live=\"assertive\">\n\t\t{#if $errors.name.length}\n\t\t\t{#each $errors.name as err}\n\t\t\t\t{err}\n\t\t\t{/each}\n\t\t{/if}\n\t&#x3C;/span>\n\t&#x3C;label for=\"email\">Email&#x3C;/label>\n\t&#x3C;input\n\t\tid=\"email\"\n\t\tname=\"email\"\n\t\ttype=\"email\"\n\t\taria-describedby={$errors.email ? \"email-error email-desc\" : \"email-desc\"}\n\t\taria-invalid={$errors.email ? \"true\" : undefined}\n\t\taria-required={$constraints.email?.required ? \"true\" : undefined}\n\t\tbind:value={$form.email}\n\t/>\n\t&#x3C;span id=\"email-desc\">It's preferred that you use your company email.&#x3C;/span>\n\t&#x3C;span id=\"email-error\" aria-live=\"assertive\">\n\t\t{#if $errors.email.length}\n\t\t\t{#each $errors.email as err}\n\t\t\t\t{err}\n\t\t\t{/each}\n\t\t{/if}\n\t&#x3C;/span>\n\t&#x3C;label for=\"password\">Password&#x3C;/label>\n\t&#x3C;input\n\t\tid=\"password\"\n\t\tname=\"password\"\n\t\ttype=\"password\"\n\t\taria-describedby={$errors.password ? \"password-error password-desc\" : \"password-desc\"}\n\t\taria-invalid={$errors.password ? \"true\" : undefined}\n\t\taria-required={$constraints.password?.required ? \"true\" : undefined}\n\t\tbind:value={$form.password}\n\t/>\n\t&#x3C;span id=\"password-desc\">Ensure the password is at least 10 characters.&#x3C;/span>\n\t&#x3C;span id=\"password-error\" aria-live=\"assertive\">\n\t\t{#if $errors.password.length}\n\t\t\t{#each $errors.password as err}\n\t\t\t\t{err}\n\t\t\t{/each}\n\t\t{/if}\n\t&#x3C;/span>\n\t&#x3C;button>Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>That's quite a bit of code required to get a simple, accessible form up and running. We can't move as quickly as we'd like to, it's not very DRY, and is ripe for copy-paste errors.</p>\n<p>All is not lost though, as the whole idea behind Formsnap is to make this process simpler, without sacrificing the flexibility that Superforms provides.</p>\n<h3>Superforms + Formsnap</h3>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { Field, Control, Label, FieldErrors, Description } from \"formsnap\";\n\timport { signupFormSchema } from \"./schema.ts\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { superForm } from \"sveltekit-superforms\";\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(signupFormSchema),\n\t});\n\tconst { form: formData, enhance } = form;\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:enhance>\n\t&#x3C;Field {form} name=\"name\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Name&#x3C;/Label>\n\t\t\t\t&#x3C;input {...props} bind:value={$formData.name} />\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Be sure to use your real name.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"email\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Email&#x3C;/Label>\n\t\t\t\t&#x3C;input {...props} type=\"email\" bind:value={$formData.email} />\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>It's preferred that you use your company email.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"password\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Password&#x3C;/Label>\n\t\t\t\t&#x3C;input {...props} type=\"password\" bind:value={$formData.password} />\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Ensure the password is at least 10 characters.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n&#x3C;/form>\n</code></pre>\n<p>That's it! We just condensed a bunch of code, while retaining the same functionality.</p>\n<h2>Next Steps</h2>\n<p>To get started using Formsnap, head over to the <a href=\"/docs/quick-start\">Quick start</a> section of the docs, where you'll learn how to install and use the library.</p>",
		"raw": "Formsnap takes the already incredible [sveltekit-superforms](https://github.com/ciscoheat/sveltekit-superforms) (winner of [Svelte Hack 2023](https://hack.sveltesociety.dev/winners) for best library), made by the brilliant [Andreas Söderlund](https://github.com/ciscoheat) and wraps it with components that make it simpler to use while making your forms accessible by default.\n\n## The Same Form, Two Ways\n\nTo showcase the value provided by Formsnap, let's take a look at a simple sign up form using only Superforms, and then using Superforms with Formsnap.\n\n### Superforms Only\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport type { PageData } from \"./$types\";\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { signupFormSchema } from \"./schema\";\n\tlet { data } = $props();\n\n\tconst { form, errors, enhance, constraints } = superForm(data.form, {\n\t\tvalidators: zodClient(signupFormSchema),\n\t});\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<label for=\"name\">Name</label>\n\t<input\n\t\tid=\"name\"\n\t\tname=\"name\"\n\t\taria-describedby={$errors.name ? \"name-error name-desc\" : \"name-desc\"}\n\t\taria-invalid={$errors.name ? \"true\" : undefined}\n\t\taria-required={$constraints.name?.required ? \"true\" : undefined}\n\t\tbind:value={$form.name}\n\t/>\n\t<span id=\"name-desc\">Be sure to use your real name.</span>\n\t<span id=\"name-error\" aria-live=\"assertive\">\n\t\t{#if $errors.name.length}\n\t\t\t{#each $errors.name as err}\n\t\t\t\t{err}\n\t\t\t{/each}\n\t\t{/if}\n\t</span>\n\t<label for=\"email\">Email</label>\n\t<input\n\t\tid=\"email\"\n\t\tname=\"email\"\n\t\ttype=\"email\"\n\t\taria-describedby={$errors.email ? \"email-error email-desc\" : \"email-desc\"}\n\t\taria-invalid={$errors.email ? \"true\" : undefined}\n\t\taria-required={$constraints.email?.required ? \"true\" : undefined}\n\t\tbind:value={$form.email}\n\t/>\n\t<span id=\"email-desc\">It's preferred that you use your company email.</span>\n\t<span id=\"email-error\" aria-live=\"assertive\">\n\t\t{#if $errors.email.length}\n\t\t\t{#each $errors.email as err}\n\t\t\t\t{err}\n\t\t\t{/each}\n\t\t{/if}\n\t</span>\n\t<label for=\"password\">Password</label>\n\t<input\n\t\tid=\"password\"\n\t\tname=\"password\"\n\t\ttype=\"password\"\n\t\taria-describedby={$errors.password ? \"password-error password-desc\" : \"password-desc\"}\n\t\taria-invalid={$errors.password ? \"true\" : undefined}\n\t\taria-required={$constraints.password?.required ? \"true\" : undefined}\n\t\tbind:value={$form.password}\n\t/>\n\t<span id=\"password-desc\">Ensure the password is at least 10 characters.</span>\n\t<span id=\"password-error\" aria-live=\"assertive\">\n\t\t{#if $errors.password.length}\n\t\t\t{#each $errors.password as err}\n\t\t\t\t{err}\n\t\t\t{/each}\n\t\t{/if}\n\t</span>\n\t<button>Submit</button>\n</form>\n```\n\nThat's quite a bit of code required to get a simple, accessible form up and running. We can't move as quickly as we'd like to, it's not very DRY, and is ripe for copy-paste errors.\n\nAll is not lost though, as the whole idea behind Formsnap is to make this process simpler, without sacrificing the flexibility that Superforms provides.\n\n### Superforms + Formsnap\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { Field, Control, Label, FieldErrors, Description } from \"formsnap\";\n\timport { signupFormSchema } from \"./schema.ts\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { superForm } from \"sveltekit-superforms\";\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(signupFormSchema),\n\t});\n\tconst { form: formData, enhance } = form;\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<Field {form} name=\"name\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Name</Label>\n\t\t\t\t<input {...props} bind:value={$formData.name} />\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Be sure to use your real name.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"email\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Email</Label>\n\t\t\t\t<input {...props} type=\"email\" bind:value={$formData.email} />\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>It's preferred that you use your company email.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"password\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Password</Label>\n\t\t\t\t<input {...props} type=\"password\" bind:value={$formData.password} />\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Ensure the password is at least 10 characters.</Description>\n\t\t<FieldErrors />\n\t</Field>\n</form>\n```\n\nThat's it! We just condensed a bunch of code, while retaining the same functionality.\n\n## Next Steps\n\nTo get started using Formsnap, head over to the [Quick start](/docs/quick-start) section of the docs, where you'll learn how to install and use the library.",
		"toc": [
			{
				"title": "The Same Form, Two Ways",
				"url": "#the-same-form-two-ways",
				"items": [
					{
						"title": "Superforms Only",
						"url": "#superforms-only",
						"items": []
					},
					{
						"title": "Superforms + Formsnap",
						"url": "#superforms--formsnap",
						"items": []
					}
				]
			},
			{
				"title": "Next Steps",
				"url": "#next-steps",
				"items": []
			}
		],
		"section": "Anchors",
		"slug": "index",
		"slugFull": "/index"
	},
	{
		"title": "Quick start",
		"description": "Learn how to take off with Formsnap by building a settings form.",
		"path": "quick-start",
		"content": "<script>\n\timport { Steps, Step } from '@svecodocs/kit';\n</script>\n<h2>Installation</h2>\n<p>Since Formsnap is built on top of <a href=\"https://superforms.rocks\">Superforms</a>, you'll need to install it as well as a schema validation library of your choice. We'll use <a href=\"https://zod.dev\">Zod</a>.</p>\n<pre><code class=\"language-bash\">npm install formsnap sveltekit-superforms zod\n</code></pre>\n<h2>Tutorial: Build a settings form</h2>\n<p>Before diving into this tutorial, it's important to be confident with <a href=\"https://superforms.rocks\">Superforms</a>, as Formsnap is built on top of it and uses the same APIs.</p>\n<steps>\n<p><step>Define a Zod schema</step></p>\n<p>This schema will represent the shape of our form data. It's used to validate the form data on the client (optional) and server, along with some other useful things.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;src/routes/settings/schema.ts&#x22;\">import { z } from \"zod\";\n\nexport const themes = [\"light\", \"dark\"] as const;\nexport const languages = [\"en\", \"es\", \"fr\"] as const;\nexport const allergies = [\"peanuts\", \"dairy\", \"gluten\", \"soy\", \"shellfish\"] as const;\n\nexport const schema = z.object({\n\temail: z.string().email(\"Please enter a valid email.\"),\n\tbio: z.string().optional(),\n\ttheme: z.enum(themes).default(\"light\"),\n\tlanguage: z.enum(languages).default(\"en\"),\n\tmarketingEmails: z.boolean().default(true),\n\tallergies: z.array(z.enum(allergies)),\n});\n</code></pre>\n<p>Looking at the schema above, we know we'll need a few different input types to represent the different data types. Here's how we'll map the schema to input types:</p>\n<ul>\n<li><code>email</code> -> <code>&#x3C;input type=\"email\"></code></li>\n<li><code>bio</code> -> <code>&#x3C;textarea></code></li>\n<li><code>theme</code> -> <code>&#x3C;input type=\"radio\"></code></li>\n<li><code>language</code> -> <code>&#x3C;select></code></li>\n<li><code>marketingEmails</code> -> <code>&#x3C;input type=\"checkbox></code></li>\n<li><code>allergies</code> -> <code>&#x3C;input type=\"checkbox\"></code> (group/multiple)</li>\n</ul>\n<p>Of course, there are other ways to represent the data, but this is the approach we'll take for this tutorial.</p>\n<p><step>Return the form from a load function</step></p>\n<p>In Superforms fashion, we'll return the form from a load function to seamlessly merge our <code>PageData</code> and <code>ActionData</code>.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;src/routes/settings/+page.server.ts&#x22;\">import type { PageServerLoad } from \"./$types\";\nimport { schema } from \"./schema\";\nimport { superValidate } from \"sveltekit-superforms\";\nimport { zod } from \"sveltekit-superforms/adapters\";\n\nexport const load: PageServerLoad = async () => {\n\treturn {\n\t\tform: await superValidate(zod(schema)),\n\t};\n};\n</code></pre>\n<p><step>Setup the form in the page component</step></p>\n<p>Now that we have our form in the <code>PageData</code> object, we can use it, along with the schema we defined earlier, to setup the form in our page component.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;src/routes/settings/+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { Field } from \"formsnap\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:enhance>\n\t&#x3C;!-- ... -->\n&#x3C;/form>\n&#x3C;SuperDebug data={$formData} />\n</code></pre>\n<p>We'll initialize the super form using <code>superForm</code> and pass in the form from the <code>PageData</code>. We'll also enable client-side validation by passing the <code>validators</code> option. Then, we'll setup the form using the <code>enhance</code> function, which will progressively enhance the form with client-side validation and other features.</p>\n<p><step>Constructing a form field</step></p>\n<p>You can think of form fields as the building blocks of your form. Each property of the schema will have a corresponding form field, which will be responsible for displaying the error messages and description.</p>\n<p>We'll start with the <code>email</code> field and work our way down.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;src/routes/settings/+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:enhance>\n\t&#x3C;Field {form} name=\"email\">\n\t\t&#x3C;!-- ... -->\n\t&#x3C;/Field>\n&#x3C;/form>\n&#x3C;SuperDebug data={$formData} />\n</code></pre>\n<p>We pass the <code>form</code> and <code>name</code> to the <code>Field</code> component, which will be used to setup the context for the field. The <code>name</code> is typed to the keys of the schema, so it's type-safe.</p>\n<p>Now let's add the remaining parts of the field:</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;src/routes/settings/+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { Field, Control, Label, Description, FieldErrors } from \"formsnap\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:enhance>\n\t&#x3C;Field {form} name=\"email\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Email&#x3C;/Label>\n\t\t\t\t&#x3C;input {...props} type=\"email\" bind:value={$formData.email} />\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Use your company email if you have one.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n&#x3C;/form>\n&#x3C;SuperDebug data={$formData} />\n</code></pre>\n<p>We've first added the <a href=\"/docs/components/control\">Control</a> component. <code>Control</code>s are used to represent a form control and its label. They keep the control and label in sync via the <code>props</code> snippet prop, which is spread onto the control. Inside the <code>Control</code>, we've added the <a href=\"/docs/components/label\">Label</a> component, which will automatically associate itself with the control the <code>props</code> are spread onto. We've also added the control itself, which is an <code>input</code> that we're binding to the <code>email</code> property of the form data.</p>\n<p>The <a href=\"/docs/components/description\">Description</a> component is optional, but it's useful for providing additional context to the user about the field. It'll be synced with the <code>aria-describedby</code> attribute on the input, so it's accessible to screen readers.</p>\n<p>The <a href=\"/docs/components/field-errors\">FieldErrors</a> component is used to display validation errors to the user. It also is synced with the <code>aria-describedby</code> attribute on the input, which can receive multiple IDs, so that screen readers are able to read the error messages in addition to the description.</p>\n<p>And that's really all it takes to setup a form field. Let's continue on with the rest of the fields.</p>\n<p><step>Add remaining form fields</step></p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;src/routes/settings/+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { Field, Control, Label, Description, FieldErrors, Fieldset, Legend } from \"formsnap\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n&#x3C;/script>\n\n&#x3C;form use:enhance class=\"mx-auto flex max-w-md flex-col\" method=\"POST\">\n\t&#x3C;Field {form} name=\"email\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Email&#x3C;/Label>\n\t\t\t\t&#x3C;input {...props} type=\"email\" bind:value={$formData.email} />\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Company email is preferred&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"bio\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Bio&#x3C;/Label>\n\t\t\t\t&#x3C;textarea {...props} bind:value={$formData.bio} />\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Tell us a bit about yourself.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"language\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Language&#x3C;/Label>\n\t\t\t\t&#x3C;select {...props} bind:value={$formData.language}>\n\t\t\t\t\t&#x3C;option value=\"fr\">French&#x3C;/option>\n\t\t\t\t\t&#x3C;option value=\"es\">Spanish&#x3C;/option>\n\t\t\t\t\t&#x3C;option value=\"en\">English&#x3C;/option>\n\t\t\t\t&#x3C;/select>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Help us address you properly.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Fieldset {form} name=\"theme\">\n\t\t&#x3C;Legend>Select your theme&#x3C;/Legend>\n\t\t{#each themes as theme}\n\t\t\t&#x3C;Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t&#x3C;Label>{theme}&#x3C;/Label>\n\t\t\t\t\t&#x3C;input {...props} type=\"radio\" value={theme} bind:group={$formData.theme} />\n\t\t\t\t{/snippet}\n\t\t\t&#x3C;/Control>\n\t\t{/each}\n\t\t&#x3C;Description>We prefer dark mode, but the choice is yours.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;Field {form} name=\"marketingEmails\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;input {...props} type=\"checkbox\" bind:checked={$formData.marketingEmails} />\n\t\t\t\t&#x3C;Label>I want to receive marketing emails&#x3C;/Label>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>Stay up to date with our latest news and offers.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Fieldset {form} name=\"allergies\">\n\t\t&#x3C;Legend>Food allergies&#x3C;/Legend>\n\t\t{#each allergies as allergy}\n\t\t\t&#x3C;Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t&#x3C;input\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\t\tvalue={allergy}\n\t\t\t\t\t/>\n\t\t\t\t\t&#x3C;Label>{allergy}&#x3C;/Label>\n\t\t\t\t{/snippet}\n\t\t\t&#x3C;/Control>\n\t\t{/each}\n\t\t&#x3C;Description>When we provide lunch, we'll accommodate your needs.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button>Submit&#x3C;/button>\n&#x3C;/form>\n&#x3C;SuperDebug data={$formData} />\n</code></pre>\n<p>You may have noticed for the <code>allergies</code> and <code>theme</code> fields, we used the <a href=\"/docs/components/fieldset\">Fieldset</a> and <a href=\"/docs/components/legend\">Legend</a> components. These are used to group related fields together and provide a title for the group, which is great for accessibility and organization. Additionally, we only use a single <a href=\"/docs/components/field-errors\">FieldError</a> and <a href=\"/docs/components/description\">Description</a> component for the entire group, and use an <a href=\"/docs/components/control\">Control</a> for each field in the group to associate the label with the control.</p>\n</steps>\n<p>And that's it! You've now successfully built a settings form with Formsnap!</p>\n<h2>Next Steps</h2>\n<p>Now that you've built your first form, you're ready to start building more complex forms with Formsnap &#x26; Superforms. Be sure to check out the rest of the documentation to learn more about the different components and APIs available to you.</p>",
		"raw": "<script>\n\timport { Steps, Step } from '@svecodocs/kit';\n</script>\n\n## Installation\n\nSince Formsnap is built on top of [Superforms](https://superforms.rocks), you'll need to install it as well as a schema validation library of your choice. We'll use [Zod](https://zod.dev).\n\n```bash\nnpm install formsnap sveltekit-superforms zod\n```\n\n## Tutorial: Build a settings form\n\nBefore diving into this tutorial, it's important to be confident with [Superforms](https://superforms.rocks), as Formsnap is built on top of it and uses the same APIs.\n\n<Steps>\n\n<Step>Define a Zod schema</Step>\n\nThis schema will represent the shape of our form data. It's used to validate the form data on the client (optional) and server, along with some other useful things.\n\n```ts title=\"src/routes/settings/schema.ts\"\nimport { z } from \"zod\";\n\nexport const themes = [\"light\", \"dark\"] as const;\nexport const languages = [\"en\", \"es\", \"fr\"] as const;\nexport const allergies = [\"peanuts\", \"dairy\", \"gluten\", \"soy\", \"shellfish\"] as const;\n\nexport const schema = z.object({\n\temail: z.string().email(\"Please enter a valid email.\"),\n\tbio: z.string().optional(),\n\ttheme: z.enum(themes).default(\"light\"),\n\tlanguage: z.enum(languages).default(\"en\"),\n\tmarketingEmails: z.boolean().default(true),\n\tallergies: z.array(z.enum(allergies)),\n});\n```\n\nLooking at the schema above, we know we'll need a few different input types to represent the different data types. Here's how we'll map the schema to input types:\n\n- `email` -> `<input type=\"email\">`\n- `bio` -> `<textarea>`\n- `theme` -> `<input type=\"radio\">`\n- `language` -> `<select>`\n- `marketingEmails` -> `<input type=\"checkbox>`\n- `allergies` -> `<input type=\"checkbox\">` (group/multiple)\n\nOf course, there are other ways to represent the data, but this is the approach we'll take for this tutorial.\n\n<Step>Return the form from a load function</Step>\n\nIn Superforms fashion, we'll return the form from a load function to seamlessly merge our `PageData` and `ActionData`.\n\n```ts title=\"src/routes/settings/+page.server.ts\"\nimport type { PageServerLoad } from \"./$types\";\nimport { schema } from \"./schema\";\nimport { superValidate } from \"sveltekit-superforms\";\nimport { zod } from \"sveltekit-superforms/adapters\";\n\nexport const load: PageServerLoad = async () => {\n\treturn {\n\t\tform: await superValidate(zod(schema)),\n\t};\n};\n```\n\n<Step>Setup the form in the page component</Step>\n\nNow that we have our form in the `PageData` object, we can use it, along with the schema we defined earlier, to setup the form in our page component.\n\n```svelte title=\"src/routes/settings/+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { Field } from \"formsnap\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- ... -->\n</form>\n<SuperDebug data={$formData} />\n```\n\nWe'll initialize the super form using `superForm` and pass in the form from the `PageData`. We'll also enable client-side validation by passing the `validators` option. Then, we'll setup the form using the `enhance` function, which will progressively enhance the form with client-side validation and other features.\n\n<Step>Constructing a form field</Step>\n\nYou can think of form fields as the building blocks of your form. Each property of the schema will have a corresponding form field, which will be responsible for displaying the error messages and description.\n\nWe'll start with the `email` field and work our way down.\n\n```svelte title=\"src/routes/settings/+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<Field {form} name=\"email\">\n\t\t<!-- ... -->\n\t</Field>\n</form>\n<SuperDebug data={$formData} />\n```\n\nWe pass the `form` and `name` to the `Field` component, which will be used to setup the context for the field. The `name` is typed to the keys of the schema, so it's type-safe.\n\nNow let's add the remaining parts of the field:\n\n```svelte title=\"src/routes/settings/+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { Field, Control, Label, Description, FieldErrors } from \"formsnap\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<Field {form} name=\"email\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Email</Label>\n\t\t\t\t<input {...props} type=\"email\" bind:value={$formData.email} />\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Use your company email if you have one.</Description>\n\t\t<FieldErrors />\n\t</Field>\n</form>\n<SuperDebug data={$formData} />\n```\n\nWe've first added the [Control](/docs/components/control) component. `Control`s are used to represent a form control and its label. They keep the control and label in sync via the `props` snippet prop, which is spread onto the control. Inside the `Control`, we've added the [Label](/docs/components/label) component, which will automatically associate itself with the control the `props` are spread onto. We've also added the control itself, which is an `input` that we're binding to the `email` property of the form data.\n\nThe [Description](/docs/components/description) component is optional, but it's useful for providing additional context to the user about the field. It'll be synced with the `aria-describedby` attribute on the input, so it's accessible to screen readers.\n\nThe [FieldErrors](/docs/components/field-errors) component is used to display validation errors to the user. It also is synced with the `aria-describedby` attribute on the input, which can receive multiple IDs, so that screen readers are able to read the error messages in addition to the description.\n\nAnd that's really all it takes to setup a form field. Let's continue on with the rest of the fields.\n\n<Step>Add remaining form fields</Step>\n\n```svelte title=\"src/routes/settings/+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { Field, Control, Label, Description, FieldErrors, Fieldset, Legend } from \"formsnap\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { allergies, schema, themes } from \"./schema.js\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData, enhance } = form;\n</script>\n\n<form use:enhance class=\"mx-auto flex max-w-md flex-col\" method=\"POST\">\n\t<Field {form} name=\"email\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Email</Label>\n\t\t\t\t<input {...props} type=\"email\" bind:value={$formData.email} />\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Company email is preferred</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"bio\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Bio</Label>\n\t\t\t\t<textarea {...props} bind:value={$formData.bio} />\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Tell us a bit about yourself.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"language\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Language</Label>\n\t\t\t\t<select {...props} bind:value={$formData.language}>\n\t\t\t\t\t<option value=\"fr\">French</option>\n\t\t\t\t\t<option value=\"es\">Spanish</option>\n\t\t\t\t\t<option value=\"en\">English</option>\n\t\t\t\t</select>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Help us address you properly.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<Fieldset {form} name=\"theme\">\n\t\t<Legend>Select your theme</Legend>\n\t\t{#each themes as theme}\n\t\t\t<Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t<Label>{theme}</Label>\n\t\t\t\t\t<input {...props} type=\"radio\" value={theme} bind:group={$formData.theme} />\n\t\t\t\t{/snippet}\n\t\t\t</Control>\n\t\t{/each}\n\t\t<Description>We prefer dark mode, but the choice is yours.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<Field {form} name=\"marketingEmails\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<input {...props} type=\"checkbox\" bind:checked={$formData.marketingEmails} />\n\t\t\t\t<Label>I want to receive marketing emails</Label>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>Stay up to date with our latest news and offers.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<Fieldset {form} name=\"allergies\">\n\t\t<Legend>Food allergies</Legend>\n\t\t{#each allergies as allergy}\n\t\t\t<Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t<input\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\t\tvalue={allergy}\n\t\t\t\t\t/>\n\t\t\t\t\t<Label>{allergy}</Label>\n\t\t\t\t{/snippet}\n\t\t\t</Control>\n\t\t{/each}\n\t\t<Description>When we provide lunch, we'll accommodate your needs.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button>Submit</button>\n</form>\n<SuperDebug data={$formData} />\n```\n\nYou may have noticed for the `allergies` and `theme` fields, we used the [Fieldset](/docs/components/fieldset) and [Legend](/docs/components/legend) components. These are used to group related fields together and provide a title for the group, which is great for accessibility and organization. Additionally, we only use a single [FieldError](/docs/components/field-errors) and [Description](/docs/components/description) component for the entire group, and use an [Control](/docs/components/control) for each field in the group to associate the label with the control.\n\n</Steps>\n\nAnd that's it! You've now successfully built a settings form with Formsnap!\n\n## Next Steps\n\nNow that you've built your first form, you're ready to start building more complex forms with Formsnap & Superforms. Be sure to check out the rest of the documentation to learn more about the different components and APIs available to you.",
		"toc": [
			{
				"title": "Installation",
				"url": "#installation",
				"items": []
			},
			{
				"title": "Tutorial: Build a settings form",
				"url": "#tutorial-build-a-settings-form",
				"items": []
			},
			{
				"title": "Next Steps",
				"url": "#next-steps",
				"items": []
			}
		],
		"section": "Anchors",
		"slug": "quick-start",
		"slugFull": "/quick-start"
	},
	{
		"title": "Styling",
		"description": "Easily style the various parts of your forms.",
		"path": "styling",
		"content": "<p>Formsnap doesn't ship with any styles by default, but it does provide a number of ways to style the various parts of your form. You can use the <code>class</code> prop to apply classes to the various components, or you can use the <code>data</code> attributes to style the components using CSS.</p>\n<h2>Data Attributes</h2>\n<p>Data attributes are applied to the various parts of your form so that you can easily style them using those attributes as selectors on a parent element or at the global level.</p>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td><code>data-fs-error</code></td><td>Applied to all the formsnap elements within a field if the field has a validation error. Using this attribute, you can customize the appearance of the input, label, etc. when the field has a validation error.</td></tr><tr><td><code>data-fs-control</code></td><td>Applied to the form control element used within a <a href=\"/docs/components/control\">Control</a> context.</td></tr><tr><td><code>data-fs-label</code></td><td>Applied to the <code>&#x3C;label></code> element rendered by the <a href=\"/docs/components/label\">Label</a> component.</td></tr><tr><td><code>data-fs-field-errors</code></td><td>Applied to the <a href=\"/docs/components/validation-error\">FieldErrors</a> container <code>&#x3C;div></code> element.</td></tr><tr><td><code>data-fs-field-error</code></td><td>Applied to the individually rendered <code>&#x3C;div></code> elements for each of the errors in the <a href=\"/docs/components/validation-error\">FieldErrors</a> component.</td></tr><tr><td><code>data-fs-description</code></td><td>Applied to the <code>&#x3C;div></code> element rendered by the <a href=\"/docs/components/description\">Description</a> component.</td></tr><tr><td><code>data-fs-fieldset</code></td><td>Applied to the <code>&#x3C;fieldset></code> element rendered by the <a href=\"/docs/components/fieldset\">Fieldset</a> component.</td></tr><tr><td><code>data-fs-legend</code></td><td>Applied to the <code>&#x3C;legend></code> element rendered by the <a href=\"/docs/components/legend\">Legend</a> component.</td></tr></tbody></table>\n<p>Here's an example of how you might use these data attributes to style the various parts of your form:</p>\n<pre><code class=\"language-css\" metastring=\"title=&#x22;app.pcss&#x22;\">[data-fs-error] {\n\tcolor: red;\n}\n\n[data-fs-control] {\n\tborder: 1px solid #ccc;\n}\n\n/* ... */\n</code></pre>\n<h2>CSS Frameworks</h2>\n<p>If you're using a CSS framework like TailwindCSS or UnoCSS, you can simply pass the <code>class</code> prop to the various components that render HTML elements under the hood. For example:</p>\n<pre><code class=\"language-svelte\" metastring=\"{7}\">&#x3C;script lang=\"ts\">\n\timport { Label } from \"formsnap\";\n&#x3C;/script>\n\n&#x3C;form>\n\t&#x3C;!-- ... -->\n\t&#x3C;Label class=\"text-black hover:text-orange-500\">First Name&#x3C;/Label>\n\t&#x3C;!-- ... -->\n&#x3C;/form>\n</code></pre>",
		"raw": "Formsnap doesn't ship with any styles by default, but it does provide a number of ways to style the various parts of your form. You can use the `class` prop to apply classes to the various components, or you can use the `data` attributes to style the components using CSS.\n\n## Data Attributes\n\nData attributes are applied to the various parts of your form so that you can easily style them using those attributes as selectors on a parent element or at the global level.\n\n<!-- prettier-ignore -->\n| Attribute | Description |\n| --------- | ----------- |\n| `data-fs-error` | Applied to all the formsnap elements within a field if the field has a validation error. Using this attribute, you can customize the appearance of the input, label, etc. when the field has a validation error. |\n| `data-fs-control` | Applied to the form control element used within a [Control](/docs/components/control) context. |\n| `data-fs-label` | Applied to the `<label>` element rendered by the [Label](/docs/components/label) component. |\n| `data-fs-field-errors` | Applied to the [FieldErrors](/docs/components/validation-error) container `<div>` element. |\n| `data-fs-field-error` | Applied to the individually rendered `<div>` elements for each of the errors in the [FieldErrors](/docs/components/validation-error) component. |\n| `data-fs-description` | Applied to the `<div>` element rendered by the [Description](/docs/components/description) component. |\n| `data-fs-fieldset` | Applied to the `<fieldset>` element rendered by the [Fieldset](/docs/components/fieldset) component. |\n| `data-fs-legend` | Applied to the `<legend>` element rendered by the [Legend](/docs/components/legend) component. |\n\nHere's an example of how you might use these data attributes to style the various parts of your form:\n\n```css title=\"app.pcss\"\n[data-fs-error] {\n\tcolor: red;\n}\n\n[data-fs-control] {\n\tborder: 1px solid #ccc;\n}\n\n/* ... */\n```\n\n## CSS Frameworks\n\nIf you're using a CSS framework like TailwindCSS or UnoCSS, you can simply pass the `class` prop to the various components that render HTML elements under the hood. For example:\n\n```svelte {7}\n<script lang=\"ts\">\n\timport { Label } from \"formsnap\";\n</script>\n\n<form>\n\t<!-- ... -->\n\t<Label class=\"text-black hover:text-orange-500\">First Name</Label>\n\t<!-- ... -->\n</form>\n```",
		"toc": [
			{
				"title": "Data Attributes",
				"url": "#data-attributes",
				"items": []
			},
			{
				"title": "CSS Frameworks",
				"url": "#css-frameworks",
				"items": []
			}
		],
		"section": "Anchors",
		"slug": "styling",
		"slugFull": "/styling"
	},
	{
		"title": "child",
		"description": "Use your own elements or components with Formsnap.",
		"path": "composition/child",
		"content": "<script>\n\timport { Callout } from '@svecodocs/kit'\n</script>\n<p>Although the provided components are the recommended and easiest way to use Formsnap, they aren't the only way. If you prefer to bring your own components or use native HTML elements, that's fine too.</p>\n<p>The <code>child</code> snippet is available on all components that render native HTML elements under the hood. When used, Formsnap won't render the default element and will expect you to spread the <code>props</code> snippet onto a custom element or component of your choosing.</p>\n<h2>Usage Example</h2>\n<p>If you wanted to use your own custom <code>Label</code> component or use scoped styles with a <code>&#x3C;label></code> element, you can do so by using the <code>child</code> snippet within the <a href=\"/docs/components/label\">Label</a> component.</p>\n<pre><code class=\"language-svelte\" metastring=\"{6-8}\">&#x3C;script lang=\"ts\">\n\timport { Label } from \"formsnap\";\n&#x3C;/script>\n\n&#x3C;Label>\n\t{#snippet child({ props })}\n\t\t&#x3C;label {...props} class=\"label\">Name&#x3C;/label>\n\t{/snippet}\n&#x3C;/Label>\n\n&#x3C;style>\n\tlabel {\n\t\tcolor: green;\n\t}\n&#x3C;/style>\n</code></pre>\n<callout type=\"note\">\n<p>If you plan to pass a custom ID to your custom element, you should first pass it to the component, which will then forward it down to the <code>props</code> snippet prop.</p>\n</callout>",
		"raw": "<script>\n\timport { Callout } from '@svecodocs/kit'\n</script>\n\nAlthough the provided components are the recommended and easiest way to use Formsnap, they aren't the only way. If you prefer to bring your own components or use native HTML elements, that's fine too.\n\nThe `child` snippet is available on all components that render native HTML elements under the hood. When used, Formsnap won't render the default element and will expect you to spread the `props` snippet onto a custom element or component of your choosing.\n\n## Usage Example\n\nIf you wanted to use your own custom `Label` component or use scoped styles with a `<label>` element, you can do so by using the `child` snippet within the [Label](/docs/components/label) component.\n\n```svelte {6-8}\n<script lang=\"ts\">\n\timport { Label } from \"formsnap\";\n</script>\n\n<Label>\n\t{#snippet child({ props })}\n\t\t<label {...props} class=\"label\">Name</label>\n\t{/snippet}\n</Label>\n\n<style>\n\tlabel {\n\t\tcolor: green;\n\t}\n</style>\n```\n\n<Callout type=\"note\">\n\nIf you plan to pass a custom ID to your custom element, you should first pass it to the component, which will then forward it down to the `props` snippet prop.\n\n</Callout>",
		"toc": [
			{
				"title": "Usage Example",
				"url": "#usage-example",
				"items": []
			}
		],
		"section": "Composition",
		"slug": "composition/child",
		"slugFull": "/composition/child"
	},
	{
		"title": "useFormControl",
		"description": "Use the form control's state for more advanced composition.",
		"path": "composition/use-form-control",
		"content": "<script>\n\timport { Callout, PropField } from '@svecodocs/kit'\n</script>\n<p>You can use <code>useFormControl</code> within the context of a <a href=\"/docs/components/control\">Control</a> component to access the state of the control and use it as you see fit.</p>\n<h2>Usage</h2>\n<p>Say we're building a custom component that contains both a custom input and label.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;LabelInput.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { useFormControl } from \"formsnap\";\n\timport CustomLabel from \"$lib/components/CustomLabel.svelte\";\n\timport CustomInput from \"$lib/components/CustomInput.svelte\";\n\n\tlet { label }: { label: string } = $props();\n\n\tconst control = useFormControl();\n&#x3C;/script>\n\n&#x3C;CustomLabel {...control.labelProps}>\n\t{label}\n&#x3C;/CustomLabel>\n&#x3C;CustomInput {...control.props} />\n</code></pre>\n<p>In this example, we're using <code>useFormControl</code> to get the spreadable for the label and control elements. We then pass those attributes to our custom components.</p>\n<p>We'd then use this within the context of a <code>Control</code> component like so:</p>\n<pre><code class=\"language-svelte\">&#x3C;Field {form} name=\"email\">\n\t&#x3C;Control>\n\t\t&#x3C;LabelInput label=\"Email address\" />\n\t&#x3C;/Control>\n&#x3C;/Field>\n</code></pre>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<propfield type=\"() => string | undefined | null\" name=\"id\">\n<p>Optionally provide a getter function that returns a custom ID to override the default control ID.</p>\n</propfield>\n<h3>Return Type</h3>\n<p><code>useFormControl</code> returns the following types:</p>\n<pre><code class=\"language-ts\">export type FormControlContext = {\n\t/** Reactive state containing the ID of the form control. */\n\treadonly id: string;\n\n\t/** Reactive state containing the attributes for the label element. */\n\treadonly labelProps: Record&#x3C;string, unknown>;\n\n\t/** Reactive state containing the attributes for the control element. */\n\treadonly props: Record&#x3C;string, unknown>;\n};\n</code></pre>\n<callout type=\"warning\">\n<p>The <code>useFormControl</code> function returns getters for the various reactive states. You should not destructure the object returned by <code>useFormControl</code> and instead use the getters directly.</p>\n</callout>",
		"raw": "<script>\n\timport { Callout, PropField } from '@svecodocs/kit'\n</script>\n\nYou can use `useFormControl` within the context of a [Control](/docs/components/control) component to access the state of the control and use it as you see fit.\n\n## Usage\n\nSay we're building a custom component that contains both a custom input and label.\n\n```svelte title=\"LabelInput.svelte\"\n<script lang=\"ts\">\n\timport { useFormControl } from \"formsnap\";\n\timport CustomLabel from \"$lib/components/CustomLabel.svelte\";\n\timport CustomInput from \"$lib/components/CustomInput.svelte\";\n\n\tlet { label }: { label: string } = $props();\n\n\tconst control = useFormControl();\n</script>\n\n<CustomLabel {...control.labelProps}>\n\t{label}\n</CustomLabel>\n<CustomInput {...control.props} />\n```\n\nIn this example, we're using `useFormControl` to get the spreadable for the label and control elements. We then pass those attributes to our custom components.\n\nWe'd then use this within the context of a `Control` component like so:\n\n```svelte\n<Field {form} name=\"email\">\n\t<Control>\n\t\t<LabelInput label=\"Email address\" />\n\t</Control>\n</Field>\n```\n\n## API Reference\n\n### Props\n\n<PropField type=\"() => string | undefined | null\" name=\"id\">\n\nOptionally provide a getter function that returns a custom ID to override the default control ID.\n\n</PropField>\n\n### Return Type\n\n`useFormControl` returns the following types:\n\n```ts\nexport type FormControlContext = {\n\t/** Reactive state containing the ID of the form control. */\n\treadonly id: string;\n\n\t/** Reactive state containing the attributes for the label element. */\n\treadonly labelProps: Record<string, unknown>;\n\n\t/** Reactive state containing the attributes for the control element. */\n\treadonly props: Record<string, unknown>;\n};\n```\n\n<Callout type=\"warning\">\n\nThe `useFormControl` function returns getters for the various reactive states. You should not destructure the object returned by `useFormControl` and instead use the getters directly.\n\n</Callout>",
		"toc": [
			{
				"title": "Usage",
				"url": "#usage",
				"items": []
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Return Type",
						"url": "#return-type",
						"items": []
					}
				]
			}
		],
		"section": "Composition",
		"slug": "composition/use-form-control",
		"slugFull": "/composition/use-form-control"
	},
	{
		"title": "useFormField",
		"description": "Use the form field's state for advanced composition with custom form components.",
		"path": "composition/use-form-field",
		"content": "<script>\n\timport { Callout, PropField } from '@svecodocs/kit'\n</script>\n<p>You can use <code>useFormField</code> within the context of a <a href=\"/docs/components/field\">Field</a>, <a href=\"/docs/components/fieldset\">Fieldset</a>, or <a href=\"/docs/components/element-field\">ElementField</a> component to access the state of the field and use it to build more advanced form components.</p>\n<h2>Usage Example</h2>\n<p>The <code>useFormField</code> function is provided for more advanced use cases where you may need to access the entire state of a form field, as well as the form itself.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;CustomFieldErrors.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { useFormField } from \"formsnap\";\n\timport type { HTMLAttributes } from \"svelte/elements\";\n\timport { schema } from \"./schema.js\";\n\timport type { Infer } from \"sveltekit-superforms\";\n\t// whatever your validation library is\n\timport { z } from \"zod\";\n\n\tlet { id, ...rest }: HTMLAttributes&#x3C;HTMLElement> = $props();\n\n\tconst field = useFormField&#x3C;Infer&#x3C;typeof schema>, \"name\">({\n\t\terrorsId: () => id,\n\t});\n&#x3C;/script>\n\n{#if $errors.length > 0}\n\t&#x3C;div class=\"error\" {id} {...rest}>\n\t\t{#each $errors as error}\n\t\t\t&#x3C;p>{error}&#x3C;/p>\n\t\t{/each}\n\t&#x3C;/div>\n{/if}\n</code></pre>\n<p>In the example above, we're using the <code>useFormField</code> function to pass a custom <code>errorsId</code> that will be used to apply appropriate ARIA attributes to the other components within the field.</p>\n<h2>API</h2>\n<h3>Props</h3>\n<propfield type=\"() => string | undefined | null\" name=\"errorsId\">\n<p>Optionally provide a getter function that returns a custom ID to override the errors container ID.</p>\n</propfield>\n<propfield type=\"() => string | undefined | null\" name=\"descriptionId\">\n<p>Optionally provide a getter function that returns a custom ID to override the description container ID.</p>\n</propfield>\n<h3>Return Type</h3>\n<p><code>useFormField</code> returns the following type:</p>\n<pre><code class=\"language-ts\">import type { FormPath } from \"sveltekit-superforms\";\n\n/**\n * State for the current form field.\n */\nexport type UseFormFieldReturn&#x3C;T extends Record&#x3C;string, unknown>, U extends FormPath&#x3C;T>> = {\n\t/** The original form store passed to the `*Field` component. */\n\tform: SuperForm&#x3C;T>;\n\n\t/** Reactive state containing the ID of the field errors container for the field. */\n\treadonly errorsId: string;\n\n\t/** Reactive state containing the ID of the description element for the field. */\n\treadonly descriptionId: string;\n\n\t/** Reactive state containing the name of the field. */\n\treadonly name: U;\n\n\t/** Reactive state containing the current validations errors for the field. */\n\treadonly errors: string[];\n\n\t/** Reactive state containing the constraints (if any) for the field. */\n\treadonly constraints: Record&#x3C;string, unknown>;\n\n\t/** Reactive state containing the tainted state of the field. */\n\treadonly tainted: boolean;\n};\n</code></pre>\n<callout type=\"warning\">\n<p>The <code>useFormField</code> function returns getters for the various reactive states. You should not destructure the object returned by <code>useFormField</code> and instead use the getters directly.</p>\n</callout>",
		"raw": "<script>\n\timport { Callout, PropField } from '@svecodocs/kit'\n</script>\n\nYou can use `useFormField` within the context of a [Field](/docs/components/field), [Fieldset](/docs/components/fieldset), or [ElementField](/docs/components/element-field) component to access the state of the field and use it to build more advanced form components.\n\n## Usage Example\n\nThe `useFormField` function is provided for more advanced use cases where you may need to access the entire state of a form field, as well as the form itself.\n\n```svelte title=\"CustomFieldErrors.svelte\"\n<script lang=\"ts\">\n\timport { useFormField } from \"formsnap\";\n\timport type { HTMLAttributes } from \"svelte/elements\";\n\timport { schema } from \"./schema.js\";\n\timport type { Infer } from \"sveltekit-superforms\";\n\t// whatever your validation library is\n\timport { z } from \"zod\";\n\n\tlet { id, ...rest }: HTMLAttributes<HTMLElement> = $props();\n\n\tconst field = useFormField<Infer<typeof schema>, \"name\">({\n\t\terrorsId: () => id,\n\t});\n</script>\n\n{#if $errors.length > 0}\n\t<div class=\"error\" {id} {...rest}>\n\t\t{#each $errors as error}\n\t\t\t<p>{error}</p>\n\t\t{/each}\n\t</div>\n{/if}\n```\n\nIn the example above, we're using the `useFormField` function to pass a custom `errorsId` that will be used to apply appropriate ARIA attributes to the other components within the field.\n\n## API\n\n### Props\n\n<PropField type=\"() => string | undefined | null\" name=\"errorsId\">\n\nOptionally provide a getter function that returns a custom ID to override the errors container ID.\n\n</PropField>\n\n<PropField type=\"() => string | undefined | null\" name=\"descriptionId\">\n\nOptionally provide a getter function that returns a custom ID to override the description container ID.\n\n</PropField>\n\n### Return Type\n\n`useFormField` returns the following type:\n\n```ts\nimport type { FormPath } from \"sveltekit-superforms\";\n\n/**\n * State for the current form field.\n */\nexport type UseFormFieldReturn<T extends Record<string, unknown>, U extends FormPath<T>> = {\n\t/** The original form store passed to the `*Field` component. */\n\tform: SuperForm<T>;\n\n\t/** Reactive state containing the ID of the field errors container for the field. */\n\treadonly errorsId: string;\n\n\t/** Reactive state containing the ID of the description element for the field. */\n\treadonly descriptionId: string;\n\n\t/** Reactive state containing the name of the field. */\n\treadonly name: U;\n\n\t/** Reactive state containing the current validations errors for the field. */\n\treadonly errors: string[];\n\n\t/** Reactive state containing the constraints (if any) for the field. */\n\treadonly constraints: Record<string, unknown>;\n\n\t/** Reactive state containing the tainted state of the field. */\n\treadonly tainted: boolean;\n};\n```\n\n<Callout type=\"warning\">\n\nThe `useFormField` function returns getters for the various reactive states. You should not destructure the object returned by `useFormField` and instead use the getters directly.\n\n</Callout>",
		"toc": [
			{
				"title": "Usage Example",
				"url": "#usage-example",
				"items": []
			},
			{
				"title": "API",
				"url": "#api",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Return Type",
						"url": "#return-type",
						"items": []
					}
				]
			}
		],
		"section": "Composition",
		"slug": "composition/use-form-field",
		"slugFull": "/composition/use-form-field"
	},
	{
		"title": "Control",
		"description": "Associates a label with and provides necessary attributes for a form control.",
		"path": "components/control",
		"content": "<script>\n\timport { Callout, PropField } from '@svecodocs/kit'\n</script>\n<p>In the context of a form, a <strong><em>control</em></strong> refers to any interactive element such as an input field, a select dropdown, or a button. This includes custom components like select dropdowns or checkboxes that function as buttons but still serve as form inputs, typically activated by clicking on a label or pressing a key.</p>\n<p>Each control and its label should be wrapped in its own <code>Control</code> component. This is important for accessibility, as it ensures that the label is associated with the control, and that the label is announced to screen readers when the control receives focus.</p>\n<callout title=\"Why a separate component?\">\n<p>A common question is <em>\"why we can't just include this logic in the various <code>Field</code> components?\"</em>.</p>\n<p>Doing so would limit the <code>Field</code> component to a single control, which would prevent them from being used for checkbox groups, radio groups, and other multi-control components. The APIs are flexible enough that you could create your own custom wrapper components to make them more convenient to use for your specific use case.</p>\n</callout>\n<p>The <code>Control</code> component doesn't render an element itself, it strictly provides context and attributes for the control via a snippet prop and state for the <a href=\"/docs/components/label\">Label</a>.</p>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;Control>\n\t{#snippet children({ props })}\n\t\t&#x3C;input type=\"text\" {...props} bind:value={$formData.name} />\n\t{/snippet}\n&#x3C;/Control>\n</code></pre>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<propfield type=\"string\" name=\"id\">\n<p>Optionally provide a unique id for the form item/control. If not provided, a unique ID will be generated for you.</p>\n<p>This is useful when another library automatically generates IDs for form items. You can pass that ID to the <code>id</code> prop and the label will be associated with that control.</p>\n</propfield>\n<propfield type=\"Snippet\" name=\"children\" required>\n<p>The children snippet is used to provide attributes for the control element/component.</p>\n</propfield>\n<h2>Composition</h2>\n<p>Since the <code>Control</code> component doesn't render an HTML element, it's a common practice to create a wrapper component around it to have consistent styling and behavior across your forms.</p>\n<p>For example, you may want to automatically include the <a href=\"/docs/components/label\">Label</a> for each item, and you want the label and children content to be wrapped in a <code>&#x3C;div></code>.</p>\n<p>Here's how you might do just that:</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;CustomControl.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { Control, Label } from \"formsnap\";\n\timport type { ComponentProps } from \"svelte\";\n\n\tlet {\n\t\tlabel,\n\t\t// Rename the children prop to childrenProp to avoid\n\t\t// conflicts with the Control component\n\t\tchildren: childrenProp,\n\t\t...restProps\n\t}: ComponentProps&#x3C;typeof Control> &#x26; {\n\t\tlabel: string;\n\t} = $props();\n&#x3C;/script>\n\n&#x3C;Control {...restProps}>\n\t{#snippet children({ props })}\n\t\t&#x3C;div class=\"flex flex-col gap-2\">\n\t\t\t&#x3C;Label>{label}&#x3C;/Label>\n\t\t\t&#x3C;!-- Forward the props to the children snippet -->\n\t\t\t{@render childrenProp({ props })}\n\t\t&#x3C;/div>\n\t{/snippet}\n&#x3C;/Control>\n</code></pre>",
		"raw": "<script>\n\timport { Callout, PropField } from '@svecodocs/kit'\n</script>\n\nIn the context of a form, a **_control_** refers to any interactive element such as an input field, a select dropdown, or a button. This includes custom components like select dropdowns or checkboxes that function as buttons but still serve as form inputs, typically activated by clicking on a label or pressing a key.\n\nEach control and its label should be wrapped in its own `Control` component. This is important for accessibility, as it ensures that the label is associated with the control, and that the label is announced to screen readers when the control receives focus.\n\n<Callout title=\"Why a separate component?\">\n\nA common question is _\"why we can't just include this logic in the various `Field` components?\"_.\n\nDoing so would limit the `Field` component to a single control, which would prevent them from being used for checkbox groups, radio groups, and other multi-control components. The APIs are flexible enough that you could create your own custom wrapper components to make them more convenient to use for your specific use case.\n\n</Callout>\n\nThe `Control` component doesn't render an element itself, it strictly provides context and attributes for the control via a snippet prop and state for the [Label](/docs/components/label).\n\n## Usage\n\n```svelte title=\"+page.svelte\"\n<Control>\n\t{#snippet children({ props })}\n\t\t<input type=\"text\" {...props} bind:value={$formData.name} />\n\t{/snippet}\n</Control>\n```\n\n## API Reference\n\n### Props\n\n<PropField type=\"string\" name=\"id\">\n\nOptionally provide a unique id for the form item/control. If not provided, a unique ID will be generated for you.\n\nThis is useful when another library automatically generates IDs for form items. You can pass that ID to the `id` prop and the label will be associated with that control.\n\n</PropField>\n\n<PropField type=\"Snippet\" name=\"children\" required>\n\nThe children snippet is used to provide attributes for the control element/component.\n\n</PropField>\n\n## Composition\n\nSince the `Control` component doesn't render an HTML element, it's a common practice to create a wrapper component around it to have consistent styling and behavior across your forms.\n\nFor example, you may want to automatically include the [Label](/docs/components/label) for each item, and you want the label and children content to be wrapped in a `<div>`.\n\nHere's how you might do just that:\n\n```svelte title=\"CustomControl.svelte\"\n<script lang=\"ts\">\n\timport { Control, Label } from \"formsnap\";\n\timport type { ComponentProps } from \"svelte\";\n\n\tlet {\n\t\tlabel,\n\t\t// Rename the children prop to childrenProp to avoid\n\t\t// conflicts with the Control component\n\t\tchildren: childrenProp,\n\t\t...restProps\n\t}: ComponentProps<typeof Control> & {\n\t\tlabel: string;\n\t} = $props();\n</script>\n\n<Control {...restProps}>\n\t{#snippet children({ props })}\n\t\t<div class=\"flex flex-col gap-2\">\n\t\t\t<Label>{label}</Label>\n\t\t\t<!-- Forward the props to the children snippet -->\n\t\t\t{@render childrenProp({ props })}\n\t\t</div>\n\t{/snippet}\n</Control>\n```",
		"toc": [
			{
				"title": "Usage",
				"url": "#usage",
				"items": []
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					}
				]
			},
			{
				"title": "Composition",
				"url": "#composition",
				"items": []
			}
		],
		"section": "Components",
		"slug": "components/control",
		"slugFull": "/components/control"
	},
	{
		"title": "Description",
		"description": "Provides an accessible description for a form field.",
		"path": "components/description",
		"content": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n<p>The <code>Description</code> component provides an accessible description for a field. It renders a <code>&#x3C;div></code> element and should be used to provide additional context or instructions for a form field.</p>\n<p>Descriptions must be used within the context of a <a href=\"/docs/components/field\">Field</a>, <a href=\"/docs/components/fieldset\">Fieldset</a>, or <a href=\"/docs/components/element-field\">ElementField</a> component and will automatically be linked to the <a href=\"/docs/components/control\">Control</a> of the field using the <code>aria-describedby</code> attribute.</p>\n<h2>Usage</h2>\n<pre><code class=\"language-svelte\" metastring=\"{8}\">&#x3C;Field name=\"name\" {form}>\n\t&#x3C;Control>\n\t\t{#snippet children({ props })}\n\t\t\t&#x3C;Label>Name&#x3C;/Label>\n\t\t\t&#x3C;input type=\"text\" {...attrs} />\n\t\t{/snippet}\n\t&#x3C;/Control>\n\t&#x3C;Description>Your full name, including your middle name.&#x3C;/Description>\n&#x3C;/Field>\n</code></pre>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<p>The <code>Description</code> component accepts all props that a standard HTML <code>&#x3C;div></code> element would accept, along with a few additional props:</p>\n<propfield type=\"HTMLElement | null\" name=\"ref\">\n<p>A reference to the underlying HTML element rendered by the <code>Description</code> component.</p>\n<pre><code class=\"language-svelte\" metastring=\"/bind:ref={descriptionRef}/\">&#x3C;Description bind:ref={descriptionRef}>\n\t&#x3C;!-- ... -->\n&#x3C;/Description>\n</code></pre>\n</propfield>\n<propfield type=\"Snippet\" name=\"child\">\n<p>If provided, the <code>Description</code> component will not render an HTML element and will instead expect you to spread the snippet's <code>props</code> onto an element of your choosing.</p>\n<p>See the <a href=\"/docs/composition/child\"><code>child</code></a> snippet documentation for more information.</p>\n</propfield>\n<propfield type=\"HTMLAttributes<HTMLElement>\" name=\"...rest\">\n<p>Any additional props provided to the <code>Description</code> component will be spread onto the underlying HTML element.</p>\n</propfield>\n<h3>Data Attributes</h3>\n<p>The following data attributes are automatically applied to the <code>&#x3C;div></code> element rendered by the <code>Description</code> component.</p>\n<propfield type=\"&#x27;&#x27;\" name=\"data-fs-description\">\n<p>Applied to the description element for selection during styling or otherwise.</p>\n</propfield>\n<propfield type=\"&#x27;&#x27; | undefined\" name=\"data-fs-error\">\n<p>Applied to the description element when a validation error exists on the field.</p>\n</propfield>",
		"raw": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n\nThe `Description` component provides an accessible description for a field. It renders a `<div>` element and should be used to provide additional context or instructions for a form field.\n\nDescriptions must be used within the context of a [Field](/docs/components/field), [Fieldset](/docs/components/fieldset), or [ElementField](/docs/components/element-field) component and will automatically be linked to the [Control](/docs/components/control) of the field using the `aria-describedby` attribute.\n\n## Usage\n\n```svelte {8}\n<Field name=\"name\" {form}>\n\t<Control>\n\t\t{#snippet children({ props })}\n\t\t\t<Label>Name</Label>\n\t\t\t<input type=\"text\" {...attrs} />\n\t\t{/snippet}\n\t</Control>\n\t<Description>Your full name, including your middle name.</Description>\n</Field>\n```\n\n## API Reference\n\n### Props\n\nThe `Description` component accepts all props that a standard HTML `<div>` element would accept, along with a few additional props:\n\n<PropField type=\"HTMLElement | null\" name=\"ref\">\n\nA reference to the underlying HTML element rendered by the `Description` component.\n\n```svelte /bind:ref={descriptionRef}/\n<Description bind:ref={descriptionRef}>\n\t<!-- ... -->\n</Description>\n```\n\n</PropField>\n\n<PropField type=\"Snippet\" name=\"child\">\n\nIf provided, the `Description` component will not render an HTML element and will instead expect you to spread the snippet's `props` onto an element of your choosing.\n\nSee the [`child`](/docs/composition/child) snippet documentation for more information.\n\n</PropField>\n\n<PropField type=\"HTMLAttributes<HTMLElement>\" name=\"...rest\">\n\nAny additional props provided to the `Description` component will be spread onto the underlying HTML element.\n\n</PropField>\n\n### Data Attributes\n\nThe following data attributes are automatically applied to the `<div>` element rendered by the `Description` component.\n\n<PropField type=\"''\" name=\"data-fs-description\">\n\nApplied to the description element for selection during styling or otherwise.\n\n</PropField>\n\n<PropField type=\"'' | undefined\" name=\"data-fs-error\">\n\nApplied to the description element when a validation error exists on the field.\n\n</PropField>",
		"toc": [
			{
				"title": "Usage",
				"url": "#usage",
				"items": []
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Data Attributes",
						"url": "#data-attributes",
						"items": []
					}
				]
			}
		],
		"section": "Components",
		"slug": "components/description",
		"slugFull": "/components/description"
	},
	{
		"title": "ElementField",
		"description": "Provides the necessary context for a form field that represents a single element in an array.",
		"path": "components/element-field",
		"content": "<script>\n\timport { PropField, Callout } from '@svecodocs/kit'\n</script>\n<p>The <code>ElementField</code> component is used to treat each element of an array as a separate form field. It's useful when you have a dynamic list of items that you want to treat as separate fields in your form.</p>\n<p><code>ElementField</code>s should be used within the context of a <a href=\"/docs/components/field\">Field</a> or <a href=\"/docs/components/fieldset\">Fieldset</a> component. <code>ElementField</code>s create their own context to scope the errors and other states of the field.</p>\n<h2>Usage</h2>\n<p>Here's an example of how you might use the <code>ElementField</code> component to create a dynamic list of URLs in a form.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { ElementField, FieldErrors, Control, Label, Fieldset, Description } from \"formsnap\";\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { z } from \"zod\";\n\n\tconst schema = z.object({\n\t\turls: z.array(z.string().url()).min(2).default([\"\", \"\"]),\n\t});\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData, enhance } = form;\n&#x3C;/script>\n\n&#x3C;form use:enhance method=\"POST\">\n\t&#x3C;Fieldset {form} name=\"urls\">\n\t\t&#x3C;Legend>Enter your URLS&#x3C;/Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t&#x3C;ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t&#x3C;Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t&#x3C;input type=\"url\" bind:value={$formData.urls[i]} {...props} />\n\t\t\t\t\t{/snippet}\n\t\t\t\t&#x3C;/Control>\n\t\t\t\t&#x3C;FieldErrors />\n\t\t\t&#x3C;/ElementField>\n\t\t{/each}\n\t\t&#x3C;Description>Your URLs will be displayed on your public profile.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>We're able to display errors for each element of the array, as well as array-level errors for the entire fieldset.</p>\n<p>Check out the <a href=\"/docs/recipes/dynamic-fields\">Dynamic Fields</a> recipe for more advanced usage of the <code>ElementField</code> component.</p>\n<callout>\n<p>The <code>ElementField</code> component doesn't render an element, it strictly provides context for its children.</p>\n</callout>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<propfield type=\"SuperForm<T>\" name=\"form\" required>\n<p>The form object returned from calling <code>superForm</code> in your component.</p>\n</propfield>\n<propfield type=\"FormPathLeaves<T>\" name=\"name\" required>\n<p>The path to the field in the form object.</p>\n</propfield>\n<h3>Snippet Props</h3>\n<p>The following snippet props are provided to the <code>children</code> snippet for convenience and ease of composition when using the <code>ElementField</code> component.</p>\n<propfield type=\"T[U]\" name=\"value\">\n<p>The value of the value store of the field.</p>\n</propfield>\n<propfield type=\"string[] | undefined\" name=\"errors\">\n<p>The value of the errors store for the field.</p>\n</propfield>\n<propfield type=\"Record<string, unknown>\" name=\"constraints\">\n<p>The constraints for the field.</p>\n</propfield>\n<propfield type=\"boolean\" name=\"tainted\">\n<p>Whether the field is tainted or not.</p>\n</propfield>\n<h2>Composition</h2>\n<p>Since the <code>ElementField</code> component doesn't render any HTML elements, it's common practice to create a wrapper component around it to have consistent styling and behavior across your forms.</p>\n<p>For example, you may always want to render the <a href=\"/docs/components/field-errors\">FieldErrors</a> component for every field. Rather than manually including it each time, you can create a wrapper <code>&#x3C;CustomElementField /></code> component that includes it automatically.</p>\n<p>To maintain the type safety of the component, we'll need to use some generics, which eslint sometimes complains about, so if you see a warning, it's likely a false positive and you can ignore it.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;CustomElementField.svelte&#x22;\">&#x3C;script lang=\"ts\" module>\n\timport type { FormPathArrays, FormPathLeaves } from \"sveltekit-superforms\";\n\ttype T = Record&#x3C;string, unknown>;\n\ttype U = unknown;\n&#x3C;/script>\n\n&#x3C;script lang=\"ts\" generics=\"T extends Record&#x3C;string, unknown>, U extends FormPathLeaves&#x3C;T>\">\n\timport { ElementField, type ElementFieldProps, FieldErrors } from \"formsnap\";\n\timport type { SuperForm } from \"sveltekit-superforms\";\n\n\tlet { form, name, children: childrenProp }: ElementFieldProps&#x3C;T, U> = $props();\n&#x3C;/script>\n\n&#x3C;ElementField {form} {name}>\n\t{#snippet children(snippetProps)}\n\t\t{@render childrenProp(snippetProps)}\n\t{/snippet}\n\t&#x3C;FieldErrors />\n&#x3C;/ElementField>\n</code></pre>",
		"raw": "<script>\n\timport { PropField, Callout } from '@svecodocs/kit'\n</script>\n\nThe `ElementField` component is used to treat each element of an array as a separate form field. It's useful when you have a dynamic list of items that you want to treat as separate fields in your form.\n\n`ElementField`s should be used within the context of a [Field](/docs/components/field) or [Fieldset](/docs/components/fieldset) component. `ElementField`s create their own context to scope the errors and other states of the field.\n\n## Usage\n\nHere's an example of how you might use the `ElementField` component to create a dynamic list of URLs in a form.\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { ElementField, FieldErrors, Control, Label, Fieldset, Description } from \"formsnap\";\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { z } from \"zod\";\n\n\tconst schema = z.object({\n\t\turls: z.array(z.string().url()).min(2).default([\"\", \"\"]),\n\t});\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData, enhance } = form;\n</script>\n\n<form use:enhance method=\"POST\">\n\t<Fieldset {form} name=\"urls\">\n\t\t<Legend>Enter your URLS</Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t<ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t<Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t<input type=\"url\" bind:value={$formData.urls[i]} {...props} />\n\t\t\t\t\t{/snippet}\n\t\t\t\t</Control>\n\t\t\t\t<FieldErrors />\n\t\t\t</ElementField>\n\t\t{/each}\n\t\t<Description>Your URLs will be displayed on your public profile.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nWe're able to display errors for each element of the array, as well as array-level errors for the entire fieldset.\n\nCheck out the [Dynamic Fields](/docs/recipes/dynamic-fields) recipe for more advanced usage of the `ElementField` component.\n\n<Callout>\n\nThe `ElementField` component doesn't render an element, it strictly provides context for its children.\n\n</Callout>\n\n## API Reference\n\n### Props\n\n<PropField type=\"SuperForm<T>\" name=\"form\" required>\n\nThe form object returned from calling `superForm` in your component.\n\n</PropField>\n\n<PropField type=\"FormPathLeaves<T>\" name=\"name\" required>\n\nThe path to the field in the form object.\n\n</PropField>\n\n### Snippet Props\n\nThe following snippet props are provided to the `children` snippet for convenience and ease of composition when using the `ElementField` component.\n\n<PropField type=\"T[U]\" name=\"value\">\n\nThe value of the value store of the field.\n\n</PropField>\n\n<PropField type=\"string[] | undefined\" name=\"errors\">\n\nThe value of the errors store for the field.\n\n</PropField>\n\n<PropField type=\"Record<string, unknown>\" name=\"constraints\">\n\nThe constraints for the field.\n\n</PropField>\n\n<PropField type=\"boolean\" name=\"tainted\">\n\nWhether the field is tainted or not.\n\n</PropField>\n\n## Composition\n\nSince the `ElementField` component doesn't render any HTML elements, it's common practice to create a wrapper component around it to have consistent styling and behavior across your forms.\n\nFor example, you may always want to render the [FieldErrors](/docs/components/field-errors) component for every field. Rather than manually including it each time, you can create a wrapper `<CustomElementField />` component that includes it automatically.\n\nTo maintain the type safety of the component, we'll need to use some generics, which eslint sometimes complains about, so if you see a warning, it's likely a false positive and you can ignore it.\n\n```svelte title=\"CustomElementField.svelte\"\n<script lang=\"ts\" module>\n\timport type { FormPathArrays, FormPathLeaves } from \"sveltekit-superforms\";\n\ttype T = Record<string, unknown>;\n\ttype U = unknown;\n</script>\n\n<script lang=\"ts\" generics=\"T extends Record<string, unknown>, U extends FormPathLeaves<T>\">\n\timport { ElementField, type ElementFieldProps, FieldErrors } from \"formsnap\";\n\timport type { SuperForm } from \"sveltekit-superforms\";\n\n\tlet { form, name, children: childrenProp }: ElementFieldProps<T, U> = $props();\n</script>\n\n<ElementField {form} {name}>\n\t{#snippet children(snippetProps)}\n\t\t{@render childrenProp(snippetProps)}\n\t{/snippet}\n\t<FieldErrors />\n</ElementField>\n```",
		"toc": [
			{
				"title": "Usage",
				"url": "#usage",
				"items": []
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Snippet Props",
						"url": "#snippet-props",
						"items": []
					}
				]
			},
			{
				"title": "Composition",
				"url": "#composition",
				"items": []
			}
		],
		"section": "Components",
		"slug": "components/element-field",
		"slugFull": "/components/element-field"
	},
	{
		"title": "FieldErrors",
		"description": "The container for validation errors for a Field, Fieldset, or ElementField.",
		"path": "components/field-errors",
		"content": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n<p>The <code>FieldErrors</code> component renders the following structure by default (attributes omitted for brevity):</p>\n<pre><code class=\"language-svelte\">&#x3C;div>\n\t{#if children}\n\t\t{@render children({ errors, errorProps })}\n\t{:else}\n\t\t{#each errors as error}\n\t\t\t&#x3C;div>{error}&#x3C;/div>\n\t\t{/each}\n\t{/if}\n&#x3C;/div>\n</code></pre>\n<p>Notice that we're populating the fallback for the children snippet, so if you don't provide children content for the <code>FieldErrors</code> component, it will render a <code>&#x3C;div></code> element for each error in the <code>errors</code> array.</p>\n<p>The <code>errors</code> are the errors for the <a href=\"/docs/components/field\">Field</a>, <a href=\"/docs/components/fieldset\">Fieldset</a>, or <a href=\"/docs/components/element-field\">ElementField</a> that the <code>FieldErrors</code> component is associated with and must be used within the context of one of those components.</p>\n<p>The errors container is automatically linked to the control of the field using the <code>aria-describedby</code> attribute when errors are present.</p>\n<h2>Usage</h2>\n<h3>Basic Usage</h3>\n<p>By default, the <code>FieldErrors</code> component will render a <code>&#x3C;div></code> element with the errors for the field it is associated with.</p>\n<pre><code class=\"language-svelte\" metastring=\"{8}\">&#x3C;Field {form} name=\"name\">\n\t&#x3C;Control>\n\t\t{#snippet children({ props })}\n\t\t\t&#x3C;Label>Name&#x3C;/Label>\n\t\t\t&#x3C;input type=\"text\" {...props} />\n\t\t{/snippet}\n\t&#x3C;/Control>\n\t&#x3C;FieldErrors />\n&#x3C;/Field>\n</code></pre>\n<h3>Custom Error Rendering</h3>\n<p>If you want to customize the rendering of the errors, you can access the errors using the <code>errors</code> snippet prop and render them however you'd like.</p>\n<pre><code class=\"language-svelte\" metastring=\"{8-14}\">&#x3C;Field {form} name=\"name\">\n\t&#x3C;Control>\n\t\t{#snippet children({ props })}\n\t\t\t&#x3C;Label>Name&#x3C;/Label>\n\t\t\t&#x3C;input type=\"text\" {...props} />\n\t\t{/snippet}\n\t&#x3C;/Control>\n\t&#x3C;FieldErrors>\n\t\t{#snippet children({ errors, errorProps })}\n\t\t\t{#each errors as err}\n\t\t\t\t&#x3C;span style=\"color: red;\" {...errorProps}>{err}&#x3C;/span>\n\t\t\t{/each}\n\t\t{/snippet}\n\t&#x3C;/FieldErrors>\n&#x3C;/Field>\n</code></pre>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<p>The <code>FieldErrors</code> component accepts all props that a standard HTML <code>&#x3C;div></code> element would accept along with a few additional props:</p>\n<propfield type=\"HTMLElement | null\" name=\"ref\">\n<p>A reference to the underlying HTML element rendered by the <code>Description</code> component.</p>\n<pre><code class=\"language-svelte\" metastring=\"/bind:ref={descriptionRef}/\">&#x3C;Description bind:ref={descriptionRef}>\n\t&#x3C;!-- ... -->\n&#x3C;/Description>\n</code></pre>\n</propfield>\n<propfield type=\"Snippet\" name=\"child\">\n<p>If provided, the <code>FieldErrors</code> component will not render an HTML element and will instead expect you to spread the snippet's <code>props</code> onto an element of your choosing.</p>\n<p>See the <a href=\"/docs/composition/child\"><code>child</code></a> snippet documentation for more information.</p>\n</propfield>\n<propfield type=\"HTMLAttributes<HTMLElement>\" name=\"...rest\">\n<p>Any additional props provided to the <code>FieldErrors</code> component will be spread onto the underlying HTML element.</p>\n</propfield>\n<h3>Attributes</h3>\n<h4>Field Errors Container</h4>\n<p>The following attributes are automatically applied to the container rendered by the <code>FieldErrors</code> component. This is also the shape of the <code>props</code> snippet prop when using the <a href=\"/docs/composition/child\">child</a> snippet.</p>\n<pre><code class=\"language-ts\">export type FieldErrorsAttrs = {\n\t/** The ID of the field error container element, used to describe the control. */\n\tid: string;\n\n\t/** Present when a validation error exists on the field. */\n\t\"data-fs-error\": string | undefined;\n\n\t/** Used for selection during styling or otherwise */\n\t\"data-fs-field-errors\": string;\n\n\t/** Notifies screen readers when a validation error occurs */\n\t\"aria-live\": \"assertive\" | \"polite\";\n\n\t/** Any additional props provided to `&#x3C;Form.Validation />` */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t[key: string]: any;\n};\n</code></pre>\n<h4>Error Elements</h4>\n<p>The following attributes are automatically applied to the individual error elements rendered by the <code>FieldErrors</code> component. This is also the shape of the <code>errorProps</code> snippet prop.</p>\n<pre><code class=\"language-ts\">export type ErrorAttrs = {\n\t/** Used for selection during styling or otherwise */\n\t\"data-fs-field-error\": string;\n\n\t/** Present when a validation error exists on the field. */\n\t\"data-fs-error\": string | undefined;\n};\n</code></pre>",
		"raw": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n\nThe `FieldErrors` component renders the following structure by default (attributes omitted for brevity):\n\n```svelte\n<div>\n\t{#if children}\n\t\t{@render children({ errors, errorProps })}\n\t{:else}\n\t\t{#each errors as error}\n\t\t\t<div>{error}</div>\n\t\t{/each}\n\t{/if}\n</div>\n```\n\nNotice that we're populating the fallback for the children snippet, so if you don't provide children content for the `FieldErrors` component, it will render a `<div>` element for each error in the `errors` array.\n\nThe `errors` are the errors for the [Field](/docs/components/field), [Fieldset](/docs/components/fieldset), or [ElementField](/docs/components/element-field) that the `FieldErrors` component is associated with and must be used within the context of one of those components.\n\nThe errors container is automatically linked to the control of the field using the `aria-describedby` attribute when errors are present.\n\n## Usage\n\n### Basic Usage\n\nBy default, the `FieldErrors` component will render a `<div>` element with the errors for the field it is associated with.\n\n```svelte {8}\n<Field {form} name=\"name\">\n\t<Control>\n\t\t{#snippet children({ props })}\n\t\t\t<Label>Name</Label>\n\t\t\t<input type=\"text\" {...props} />\n\t\t{/snippet}\n\t</Control>\n\t<FieldErrors />\n</Field>\n```\n\n### Custom Error Rendering\n\nIf you want to customize the rendering of the errors, you can access the errors using the `errors` snippet prop and render them however you'd like.\n\n```svelte {8-14}\n<Field {form} name=\"name\">\n\t<Control>\n\t\t{#snippet children({ props })}\n\t\t\t<Label>Name</Label>\n\t\t\t<input type=\"text\" {...props} />\n\t\t{/snippet}\n\t</Control>\n\t<FieldErrors>\n\t\t{#snippet children({ errors, errorProps })}\n\t\t\t{#each errors as err}\n\t\t\t\t<span style=\"color: red;\" {...errorProps}>{err}</span>\n\t\t\t{/each}\n\t\t{/snippet}\n\t</FieldErrors>\n</Field>\n```\n\n## API Reference\n\n### Props\n\nThe `FieldErrors` component accepts all props that a standard HTML `<div>` element would accept along with a few additional props:\n\n<PropField type=\"HTMLElement | null\" name=\"ref\">\n\nA reference to the underlying HTML element rendered by the `Description` component.\n\n```svelte /bind:ref={descriptionRef}/\n<Description bind:ref={descriptionRef}>\n\t<!-- ... -->\n</Description>\n```\n\n</PropField>\n\n<PropField type=\"Snippet\" name=\"child\">\n\nIf provided, the `FieldErrors` component will not render an HTML element and will instead expect you to spread the snippet's `props` onto an element of your choosing.\n\nSee the [`child`](/docs/composition/child) snippet documentation for more information.\n\n</PropField>\n\n<PropField type=\"HTMLAttributes<HTMLElement>\" name=\"...rest\">\n\nAny additional props provided to the `FieldErrors` component will be spread onto the underlying HTML element.\n\n</PropField>\n\n### Attributes\n\n#### Field Errors Container\n\nThe following attributes are automatically applied to the container rendered by the `FieldErrors` component. This is also the shape of the `props` snippet prop when using the [child](/docs/composition/child) snippet.\n\n```ts\nexport type FieldErrorsAttrs = {\n\t/** The ID of the field error container element, used to describe the control. */\n\tid: string;\n\n\t/** Present when a validation error exists on the field. */\n\t\"data-fs-error\": string | undefined;\n\n\t/** Used for selection during styling or otherwise */\n\t\"data-fs-field-errors\": string;\n\n\t/** Notifies screen readers when a validation error occurs */\n\t\"aria-live\": \"assertive\" | \"polite\";\n\n\t/** Any additional props provided to `<Form.Validation />` */\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t[key: string]: any;\n};\n```\n\n#### Error Elements\n\nThe following attributes are automatically applied to the individual error elements rendered by the `FieldErrors` component. This is also the shape of the `errorProps` snippet prop.\n\n```ts\nexport type ErrorAttrs = {\n\t/** Used for selection during styling or otherwise */\n\t\"data-fs-field-error\": string;\n\n\t/** Present when a validation error exists on the field. */\n\t\"data-fs-error\": string | undefined;\n};\n```",
		"toc": [
			{
				"title": "Usage",
				"url": "#usage",
				"items": [
					{
						"title": "Basic Usage",
						"url": "#basic-usage",
						"items": []
					},
					{
						"title": "Custom Error Rendering",
						"url": "#custom-error-rendering",
						"items": []
					}
				]
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Attributes",
						"url": "#attributes",
						"items": [
							{
								"title": "Field Errors Container",
								"url": "#field-errors-container",
								"items": []
							},
							{
								"title": "Error Elements",
								"url": "#error-elements",
								"items": []
							}
						]
					}
				]
			}
		],
		"section": "Components",
		"slug": "components/field-errors",
		"slugFull": "/components/field-errors"
	},
	{
		"title": "Field",
		"description": "Provides the necessary context for a form field.",
		"path": "components/field",
		"content": "<script>\n\timport { PropField, Callout } from '@svecodocs/kit'\n</script>\n<p>The <code>Field</code> component provides the necessary context for its children to react\nto changes in the form state, as well as provides necessary information about the field,\nsuch as the ids needed for aria attributes, and a lot more.</p>\n<p>Each <code>Field</code> creates its own context, and the children of the field only access\nthe immediate parent's context.</p>\n<callout>\n<p>The <code>Field</code> component doesn't render an element, it strictly provides context.</p>\n</callout>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<propfield type=\"SuperForm<T>\" name=\"form\" required>\n<p>The form object returned from calling <code>superForm</code> in your component.</p>\n</propfield>\n<propfield type=\"FormPath<T>\" name=\"name\" required>\n<p>The path to the field in the form object.</p>\n</propfield>\n<h3>Snippet Props</h3>\n<p>The following snippet props are provided to the <code>children</code> snippet for convenience and ease of composition when using the <code>Field</code> component.</p>\n<propfield type=\"T[U]\" name=\"value\">\n<p>The value of the value store of the field.</p>\n</propfield>\n<propfield type=\"string[] | undefined\" name=\"errors\">\n<p>The value of the errors store for the field.</p>\n</propfield>\n<propfield type=\"Record<string, unknown>\" name=\"constraints\">\n<p>The constraints for the field.</p>\n</propfield>\n<propfield type=\"boolean\" name=\"tainted\">\n<p>Whether the field is tainted or not.</p>\n</propfield>\n<h2>Composition</h2>\n<p>Since the <code>Field</code> component doesn't render any HTML elements, it's a common practice to create a wrapper component around it to have consistent styling and behavior across your forms.</p>\n<p>For example, you may always want to render the <a href=\"/docs/components/field-errors\">FieldErrors</a> component for every field. Instead of manually including it every time, you can create a wrapper <code>&#x3C;CustomField /></code> component that includes it automatically.</p>\n<p>To maintain the type safety of the component, we'll need to use some generics, which eslint sometimes complains about, so if you see a warning, it's likely a false positive and you can ignore it.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;CustomField.svelte&#x22;\">&#x3C;script lang=\"ts\" module>\n\timport type { FormPath } from \"sveltekit-superforms\";\n\n\t// the form object\n\ttype T = Record&#x3C;string, unknown>;\n\t// the path/name of the field in the form object\n\ttype U = unknown;\n&#x3C;/script>\n\n&#x3C;script lang=\"ts\" generics=\"T extends Record&#x3C;string, unknown>, U extends FormPath&#x3C;T>\">\n\timport { Field, type FieldProps, FieldErrors } from \"formsnap\";\n\timport type { SuperForm } from \"sveltekit-superforms\";\n\n\tlet { form, name, children: childrenProp }: FieldProps&#x3C;T, U> = $props();\n&#x3C;/script>\n\n&#x3C;Field {form} {name}>\n\t{#snippet children(snippetProps)}\n\t\t{@render childrenProp(snippetProps)}\n\t\t&#x3C;FieldErrors />\n\t{/snippet}\n&#x3C;/Field>\n</code></pre>",
		"raw": "<script>\n\timport { PropField, Callout } from '@svecodocs/kit'\n</script>\n\nThe `Field` component provides the necessary context for its children to react\nto changes in the form state, as well as provides necessary information about the field,\nsuch as the ids needed for aria attributes, and a lot more.\n\nEach `Field` creates its own context, and the children of the field only access\nthe immediate parent's context.\n\n<Callout>\n\nThe `Field` component doesn't render an element, it strictly provides context.\n\n</Callout>\n\n## API Reference\n\n### Props\n\n<PropField type=\"SuperForm<T>\" name=\"form\" required>\n\nThe form object returned from calling `superForm` in your component.\n\n</PropField>\n\n<PropField type=\"FormPath<T>\" name=\"name\" required>\n\nThe path to the field in the form object.\n\n</PropField>\n\n### Snippet Props\n\nThe following snippet props are provided to the `children` snippet for convenience and ease of composition when using the `Field` component.\n\n<PropField type=\"T[U]\" name=\"value\">\n\nThe value of the value store of the field.\n\n</PropField>\n\n<PropField type=\"string[] | undefined\" name=\"errors\">\n\nThe value of the errors store for the field.\n\n</PropField>\n\n<PropField type=\"Record<string, unknown>\" name=\"constraints\">\n\nThe constraints for the field.\n\n</PropField>\n\n<PropField type=\"boolean\" name=\"tainted\">\n\nWhether the field is tainted or not.\n\n</PropField>\n\n## Composition\n\nSince the `Field` component doesn't render any HTML elements, it's a common practice to create a wrapper component around it to have consistent styling and behavior across your forms.\n\nFor example, you may always want to render the [FieldErrors](/docs/components/field-errors) component for every field. Instead of manually including it every time, you can create a wrapper `<CustomField />` component that includes it automatically.\n\nTo maintain the type safety of the component, we'll need to use some generics, which eslint sometimes complains about, so if you see a warning, it's likely a false positive and you can ignore it.\n\n```svelte title=\"CustomField.svelte\"\n<script lang=\"ts\" module>\n\timport type { FormPath } from \"sveltekit-superforms\";\n\n\t// the form object\n\ttype T = Record<string, unknown>;\n\t// the path/name of the field in the form object\n\ttype U = unknown;\n</script>\n\n<script lang=\"ts\" generics=\"T extends Record<string, unknown>, U extends FormPath<T>\">\n\timport { Field, type FieldProps, FieldErrors } from \"formsnap\";\n\timport type { SuperForm } from \"sveltekit-superforms\";\n\n\tlet { form, name, children: childrenProp }: FieldProps<T, U> = $props();\n</script>\n\n<Field {form} {name}>\n\t{#snippet children(snippetProps)}\n\t\t{@render childrenProp(snippetProps)}\n\t\t<FieldErrors />\n\t{/snippet}\n</Field>\n```",
		"toc": [
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Snippet Props",
						"url": "#snippet-props",
						"items": []
					}
				]
			},
			{
				"title": "Composition",
				"url": "#composition",
				"items": []
			}
		],
		"section": "Components",
		"slug": "components/field",
		"slugFull": "/components/field"
	},
	{
		"title": "Fieldset",
		"description": "Groups related form controls or fields and extends the Field component.",
		"path": "components/fieldset",
		"content": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n<p>The <code>Fieldset</code> component is used to follow the <a href=\"https://www.w3.org/WAI/tutorials/forms/grouping/#associating-related-controls-with-fieldset\">W3C Grouping Controls</a> recommendation for associating related form controls. It renders a <code>&#x3C;fieldset></code> element and should always be used in conjunction with the <a href=\"/docs/components/legend\">Legend</a> component to provide a title for the group.</p>\n<p>This component automatically includes the <a href=\"/docs/components/field\">Field</a> component, so you don't need to worry about wrapping it yourself, just be sure to pass the <code>form</code> and <code>name</code> props to the <code>Fieldset</code> as you would with the <code>Field</code> component.</p>\n<h2>When to use a fieldset</h2>\n<h3>Radio Groups</h3>\n<p>When you have a group of radio buttons related to a single field, you should use a <code>Fieldset</code> to group them together.</p>\n<pre><code class=\"language-svelte\" metastring=\"{1-2,13}\">&#x3C;Fieldset {form} name=\"theme\">\n\t&#x3C;Legend>Select your theme&#x3C;/Legend>\n\t{#each themes as theme}\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;input {...props} type=\"radio\" bind:group={$formData.theme} value={theme} />\n\t\t\t\t&#x3C;Label>{theme}&#x3C;/Label>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t{/each}\n\t&#x3C;Description>Help us understand your preferences by selecting a theme.&#x3C;/Description>\n\t&#x3C;FieldErrors />\n&#x3C;/Fieldset>\n</code></pre>\n<h3>Checkbox Groups</h3>\n<p>When you have a group of checkboxes related to a single field, typically used for multiple selections, you should use a <code>Fieldset</code> to group them together.</p>\n<pre><code class=\"language-svelte\" metastring=\"{1-2,18}\">&#x3C;Fieldset {form} name=\"allergies\">\n\t&#x3C;Legend>Any food allergies?&#x3C;/Legend>\n\t{#each allergies as allergy}\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;input\n\t\t\t\t\t{...props}\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\tvalue={allergy}\n\t\t\t\t/>\n\t\t\t\t&#x3C;Label>{allergy}&#x3C;/Label>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t{/each}\n\t&#x3C;Description>We'll make sure to accommodate your dietary needs.&#x3C;/Description>\n\t&#x3C;FieldErrors />\n&#x3C;/Fieldset>\n</code></pre>\n<h3>Grouped Form Sections</h3>\n<p>When you have a large form with multiple sections containing related fields, such as a \"Billing Address\" and a \"Shipping Address\", you should use a <code>&#x3C;fieldset></code> to group the related fields together. You won't use the <code>Fieldset</code> component directly in this case, since it doesn't represent a field on the form.</p>\n<pre><code class=\"language-svelte\">&#x3C;form>\n\t&#x3C;fieldset>\n\t\t&#x3C;legend>Billing Address&#x3C;/legend>\n\t\t&#x3C;!-- ... billing address fields -->\n\t&#x3C;/fieldset>\n\t&#x3C;fieldset>\n\t\t&#x3C;legend>Shipping Address&#x3C;/legend>\n\t\t&#x3C;!-- ... shipping address fields -->\n\t&#x3C;/fieldset>\n&#x3C;/form>\n</code></pre>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<p>The <code>Fieldset</code> component renders a <code>&#x3C;fieldset></code> element and accepts the following props:</p>\n<propfield type=\"SuperForm<T>\" name=\"form\" required>\n<p>The form object returned from calling <code>superForm</code> in your component.</p>\n</propfield>\n<propfield type=\"FormPath<T>\" name=\"name\" required>\n<p>The path to the field in the form object.</p>\n</propfield>\n<propfield type=\"HTMLElement | null\" name=\"ref\">\n<p>A <code>$bindable</code> reference to the underlying HTML element rendered by the <code>Fieldset</code> component.</p>\n</propfield>\n<propfield type=\"Snippet\" name=\"child\">\n<p>If provided, the <code>Fieldset</code> component will not render an HTML element and will instead expect you to spread the snippet's <code>props</code> onto an element of your choosing.</p>\n<p>See the <a href=\"/docs/composition/child\"><code>child</code></a> snippet documentation for more information.</p>\n</propfield>\n<propfield type=\"HTMLAttributes<HTMLFieldSetElement>\" name=\"...rest\">\n<p>Any additional props provided to the <code>Fieldset</code> component will be spread onto the underlying HTML element.</p>\n</propfield>\n<h3>Snippet Props (children)</h3>\n<p>The following snippet props are provided to the <code>children</code> snippet for convenience and ease of composition when using the <code>ElementField</code> component.</p>\n<propfield type=\"T[U]\" name=\"value\">\n<p>The value of the value store of the field.</p>\n</propfield>\n<propfield type=\"string[] | undefined\" name=\"errors\">\n<p>The value of the errors store for the field.</p>\n</propfield>\n<propfield type=\"Record<string, unknown>\" name=\"constraints\">\n<p>The constraints for the field.</p>\n</propfield>\n<propfield type=\"boolean\" name=\"tainted\">\n<p>Whether the field is tainted or not.</p>\n</propfield>\n<h3>Snippet Props (child)</h3>\n<p>The following snippet props are provided to the <code>child</code> snippet for convenience and ease of composition when using the <code>ElementField</code> component.</p>\n<propfield type=\"Record<string, unknown>\" name=\"props\">\n<p>The props to spread onto your custom <code>&#x3C;fieldset></code> element/component.</p>\n</propfield>\n<propfield type=\"T[U]\" name=\"value\">\n<p>The value of the value store of the field.</p>\n</propfield>\n<propfield type=\"string[] | undefined\" name=\"errors\">\n<p>The value of the errors store for the field.</p>\n</propfield>\n<propfield type=\"Record<string, unknown>\" name=\"constraints\">\n<p>The constraints for the field.</p>\n</propfield>\n<propfield type=\"boolean\" name=\"tainted\">\n<p>Whether the field is tainted or not.</p>\n</propfield>\n<h3>Data Attributes</h3>\n<p>The following data attributes are automatically applied to the <code>&#x3C;fieldset></code> element rendered by the <code>Fieldset</code> component.</p>\n<propfield type=\"&#x27;&#x27;\" name=\"data-fs-fieldset\">\n<p>Applied to the element for selection during styling or otherwise.</p>\n</propfield>\n<propfield type=\"&#x27;&#x27; | undefined\" name=\"data-fs-error\">\n<p>Applied to the element when a validation error exists on the field.</p>\n</propfield>",
		"raw": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n\nThe `Fieldset` component is used to follow the [W3C Grouping Controls](https://www.w3.org/WAI/tutorials/forms/grouping/#associating-related-controls-with-fieldset) recommendation for associating related form controls. It renders a `<fieldset>` element and should always be used in conjunction with the [Legend](/docs/components/legend) component to provide a title for the group.\n\nThis component automatically includes the [Field](/docs/components/field) component, so you don't need to worry about wrapping it yourself, just be sure to pass the `form` and `name` props to the `Fieldset` as you would with the `Field` component.\n\n## When to use a fieldset\n\n### Radio Groups\n\nWhen you have a group of radio buttons related to a single field, you should use a `Fieldset` to group them together.\n\n```svelte {1-2,13}\n<Fieldset {form} name=\"theme\">\n\t<Legend>Select your theme</Legend>\n\t{#each themes as theme}\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<input {...props} type=\"radio\" bind:group={$formData.theme} value={theme} />\n\t\t\t\t<Label>{theme}</Label>\n\t\t\t{/snippet}\n\t\t</Control>\n\t{/each}\n\t<Description>Help us understand your preferences by selecting a theme.</Description>\n\t<FieldErrors />\n</Fieldset>\n```\n\n### Checkbox Groups\n\nWhen you have a group of checkboxes related to a single field, typically used for multiple selections, you should use a `Fieldset` to group them together.\n\n```svelte {1-2,18}\n<Fieldset {form} name=\"allergies\">\n\t<Legend>Any food allergies?</Legend>\n\t{#each allergies as allergy}\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<input\n\t\t\t\t\t{...props}\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\tvalue={allergy}\n\t\t\t\t/>\n\t\t\t\t<Label>{allergy}</Label>\n\t\t\t{/snippet}\n\t\t</Control>\n\t{/each}\n\t<Description>We'll make sure to accommodate your dietary needs.</Description>\n\t<FieldErrors />\n</Fieldset>\n```\n\n### Grouped Form Sections\n\nWhen you have a large form with multiple sections containing related fields, such as a \"Billing Address\" and a \"Shipping Address\", you should use a `<fieldset>` to group the related fields together. You won't use the `Fieldset` component directly in this case, since it doesn't represent a field on the form.\n\n```svelte\n<form>\n\t<fieldset>\n\t\t<legend>Billing Address</legend>\n\t\t<!-- ... billing address fields -->\n\t</fieldset>\n\t<fieldset>\n\t\t<legend>Shipping Address</legend>\n\t\t<!-- ... shipping address fields -->\n\t</fieldset>\n</form>\n```\n\n## API Reference\n\n### Props\n\nThe `Fieldset` component renders a `<fieldset>` element and accepts the following props:\n\n<PropField type=\"SuperForm<T>\" name=\"form\" required>\n\nThe form object returned from calling `superForm` in your component.\n\n</PropField>\n\n<PropField type=\"FormPath<T>\" name=\"name\" required>\n\nThe path to the field in the form object.\n\n</PropField>\n\n<PropField type=\"HTMLElement | null\" name=\"ref\">\n\nA `$bindable` reference to the underlying HTML element rendered by the `Fieldset` component.\n\n</PropField>\n\n<PropField type=\"Snippet\" name=\"child\">\n\nIf provided, the `Fieldset` component will not render an HTML element and will instead expect you to spread the snippet's `props` onto an element of your choosing.\n\nSee the [`child`](/docs/composition/child) snippet documentation for more information.\n\n</PropField>\n\n<PropField type=\"HTMLAttributes<HTMLFieldSetElement>\" name=\"...rest\">\n\nAny additional props provided to the `Fieldset` component will be spread onto the underlying HTML element.\n\n</PropField>\n\n### Snippet Props (children)\n\nThe following snippet props are provided to the `children` snippet for convenience and ease of composition when using the `ElementField` component.\n\n<PropField type=\"T[U]\" name=\"value\">\n\nThe value of the value store of the field.\n\n</PropField>\n\n<PropField type=\"string[] | undefined\" name=\"errors\">\n\nThe value of the errors store for the field.\n\n</PropField>\n\n<PropField type=\"Record<string, unknown>\" name=\"constraints\">\n\nThe constraints for the field.\n\n</PropField>\n\n<PropField type=\"boolean\" name=\"tainted\">\n\nWhether the field is tainted or not.\n\n</PropField>\n\n### Snippet Props (child)\n\nThe following snippet props are provided to the `child` snippet for convenience and ease of composition when using the `ElementField` component.\n\n<PropField type=\"Record<string, unknown>\" name=\"props\">\n\nThe props to spread onto your custom `<fieldset>` element/component.\n\n</PropField>\n\n<PropField type=\"T[U]\" name=\"value\">\n\nThe value of the value store of the field.\n\n</PropField>\n\n<PropField type=\"string[] | undefined\" name=\"errors\">\n\nThe value of the errors store for the field.\n\n</PropField>\n\n<PropField type=\"Record<string, unknown>\" name=\"constraints\">\n\nThe constraints for the field.\n\n</PropField>\n\n<PropField type=\"boolean\" name=\"tainted\">\n\nWhether the field is tainted or not.\n\n</PropField>\n\n### Data Attributes\n\nThe following data attributes are automatically applied to the `<fieldset>` element rendered by the `Fieldset` component.\n\n<PropField type=\"''\" name=\"data-fs-fieldset\">\n\nApplied to the element for selection during styling or otherwise.\n\n</PropField>\n\n<PropField type=\"'' | undefined\" name=\"data-fs-error\">\n\nApplied to the element when a validation error exists on the field.\n\n</PropField>",
		"toc": [
			{
				"title": "When to use a fieldset",
				"url": "#when-to-use-a-fieldset",
				"items": [
					{
						"title": "Radio Groups",
						"url": "#radio-groups",
						"items": []
					},
					{
						"title": "Checkbox Groups",
						"url": "#checkbox-groups",
						"items": []
					},
					{
						"title": "Grouped Form Sections",
						"url": "#grouped-form-sections",
						"items": []
					}
				]
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					},
					{
						"title": "Snippet Props (children)",
						"url": "#snippet-props-children",
						"items": []
					},
					{
						"title": "Snippet Props (child)",
						"url": "#snippet-props-child",
						"items": []
					},
					{
						"title": "Data Attributes",
						"url": "#data-attributes",
						"items": []
					}
				]
			}
		],
		"section": "Components",
		"slug": "components/fieldset",
		"slugFull": "/components/fieldset"
	},
	{
		"title": "Label",
		"description": "Renders a label element for a control.",
		"path": "components/label",
		"content": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n<p>The <code>Label</code> component must be used as a child of a <a href=\"/docs/components/control\">Control</a> component. It renders a <code>&#x3C;label></code> element and includes the necessary attributes to associate it with the control.</p>\n<h2>Usage</h2>\n<p>When using a <code>Label</code> inside a <a href=\"/docs/components/control\">Control</a>, you don't need to worry about the <code>for</code> attribute. Formsnap handles that for you.</p>\n<pre><code class=\"language-svelte\" metastring=\"{3}\">&#x3C;Field {form} name=\"name\">\n\t&#x3C;Control>\n\t\t{#snippet children({ props })}\n\t\t\t&#x3C;Label>Name&#x3C;/Label>\n\t\t\t&#x3C;input type=\"text\" {...props} />\n\t\t{/snippet}\n\t&#x3C;/Control>\n&#x3C;/Field>\n</code></pre>\n<h2>API Reference</h2>\n<h3>Props</h3>\n<propfield type=\"HTMLElement | null\" name=\"ref\">\n<p>A <code>$bindable</code> reference to the underlying <code>&#x3C;label></code> element rendered by the <code>Label</code> component.</p>\n</propfield>\n<propfield type=\"Snippet\" name=\"child\">\n<p>If provided, the <code>Label</code> component will not render an HTML element and will instead expect you to spread the snippet's <code>props</code> onto an element of your choosing.</p>\n<p>See the <a href=\"/docs/composition/child\"><code>child</code></a> snippet documentation for more information.</p>\n</propfield>\n<propfield type=\"HTMLAttributes<HTMLLabelElement>\" name=\"...rest\">\n<p>Any additional props provided to the <code>Label</code> component will be spread onto the underlying HTML element.</p>\n</propfield>\n<h2>Data Attributes</h2>\n<p>The following data attributes are automatically applied to the element rendered by the <code>Label</code> component.</p>\n<propfield type=\"&#x27;&#x27;\" name=\"data-fs-label\">\n<p>Applied to the element for selection during styling or otherwise.</p>\n</propfield>\n<propfield type=\"&#x27;&#x27; | undefined\" name=\"data-fs-error\">\n<p>Applied to the element when a validation error exists on the field.</p>\n</propfield>",
		"raw": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n\nThe `Label` component must be used as a child of a [Control](/docs/components/control) component. It renders a `<label>` element and includes the necessary attributes to associate it with the control.\n\n## Usage\n\nWhen using a `Label` inside a [Control](/docs/components/control), you don't need to worry about the `for` attribute. Formsnap handles that for you.\n\n```svelte {3}\n<Field {form} name=\"name\">\n\t<Control>\n\t\t{#snippet children({ props })}\n\t\t\t<Label>Name</Label>\n\t\t\t<input type=\"text\" {...props} />\n\t\t{/snippet}\n\t</Control>\n</Field>\n```\n\n## API Reference\n\n### Props\n\n<PropField type=\"HTMLElement | null\" name=\"ref\">\n\nA `$bindable` reference to the underlying `<label>` element rendered by the `Label` component.\n\n</PropField>\n\n<PropField type=\"Snippet\" name=\"child\">\n\nIf provided, the `Label` component will not render an HTML element and will instead expect you to spread the snippet's `props` onto an element of your choosing.\n\nSee the [`child`](/docs/composition/child) snippet documentation for more information.\n\n</PropField>\n\n<PropField type=\"HTMLAttributes<HTMLLabelElement>\" name=\"...rest\">\n\nAny additional props provided to the `Label` component will be spread onto the underlying HTML element.\n\n</PropField>\n\n## Data Attributes\n\nThe following data attributes are automatically applied to the element rendered by the `Label` component.\n\n<PropField type=\"''\" name=\"data-fs-label\">\n\nApplied to the element for selection during styling or otherwise.\n\n</PropField>\n\n<PropField type=\"'' | undefined\" name=\"data-fs-error\">\n\nApplied to the element when a validation error exists on the field.\n\n</PropField>",
		"toc": [
			{
				"title": "Usage",
				"url": "#usage",
				"items": []
			},
			{
				"title": "API Reference",
				"url": "#api-reference",
				"items": [
					{
						"title": "Props",
						"url": "#props",
						"items": []
					}
				]
			},
			{
				"title": "Data Attributes",
				"url": "#data-attributes",
				"items": []
			}
		],
		"section": "Components",
		"slug": "components/label",
		"slugFull": "/components/label"
	},
	{
		"title": "Legend",
		"description": "Provides a title for a group of related form controls.",
		"path": "components/legend",
		"content": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n<p>You should always use the <code>Legend</code> component in conjunction with the <a href=\"/docs/components/fieldset\">Fieldset</a> component to provide a title for a group of related form controls. See the the <code>Fieldset</code> component's <a href=\"/docs/components/fieldset\">documentation</a> for more information on when to use a fieldset.</p>\n<h2>Props</h2>\n<p>The <code>Legend</code> component renders a <code>&#x3C;legend></code> element and accepts all props that a standard HTML <code>&#x3C;legend></code> element would accept along with a few additional props:</p>\n<propfield type=\"HTMLElement | null\" name=\"ref\">\n<p>A <code>$bindable</code> reference to the underlying HTML element rendered by the <code>Legend</code> component.</p>\n</propfield>\n<propfield type=\"Snippet\" name=\"child\">\n<p>If provided, the <code>Legend</code> component will not render an HTML element and will instead expect you to spread the snippet's <code>props</code> onto an element of your choosing.</p>\n<p>See the <a href=\"/docs/composition/child\"><code>child</code></a> snippet documentation for more information.</p>\n</propfield>\n<propfield type=\"HTMLAttributes<HTMLLegendElement>\" name=\"...rest\">\n<p>Any additional props provided to the <code>Legend</code> component will be spread onto the underlying HTML element.</p>\n</propfield>\n<h2>Data Attributes</h2>\n<p>The following attributes are automatically applied to the element rendered by the <code>Legend</code> component.</p>\n<propfield type=\"&#x27;&#x27;\" name=\"data-fs-legend\">\n<p>Applied to the element for selection during styling or otherwise.</p>\n</propfield>\n<propfield type=\"&#x27;&#x27; | undefined\" name=\"data-fs-error\">\n<p>Applied to the element when a validation error exists on the field.</p>\n</propfield>",
		"raw": "<script>\n\timport { PropField } from '@svecodocs/kit'\n</script>\n\nYou should always use the `Legend` component in conjunction with the [Fieldset](/docs/components/fieldset) component to provide a title for a group of related form controls. See the the `Fieldset` component's [documentation](/docs/components/fieldset) for more information on when to use a fieldset.\n\n## Props\n\nThe `Legend` component renders a `<legend>` element and accepts all props that a standard HTML `<legend>` element would accept along with a few additional props:\n\n<PropField type=\"HTMLElement | null\" name=\"ref\">\n\nA `$bindable` reference to the underlying HTML element rendered by the `Legend` component.\n\n</PropField>\n\n<PropField type=\"Snippet\" name=\"child\">\n\nIf provided, the `Legend` component will not render an HTML element and will instead expect you to spread the snippet's `props` onto an element of your choosing.\n\nSee the [`child`](/docs/composition/child) snippet documentation for more information.\n\n</PropField>\n\n<PropField type=\"HTMLAttributes<HTMLLegendElement>\" name=\"...rest\">\n\nAny additional props provided to the `Legend` component will be spread onto the underlying HTML element.\n\n</PropField>\n\n## Data Attributes\n\nThe following attributes are automatically applied to the element rendered by the `Legend` component.\n\n<PropField type=\"''\" name=\"data-fs-legend\">\n\nApplied to the element for selection during styling or otherwise.\n\n</PropField>\n\n<PropField type=\"'' | undefined\" name=\"data-fs-error\">\n\nApplied to the element when a validation error exists on the field.\n\n</PropField>",
		"toc": [
			{
				"title": "Props",
				"url": "#props",
				"items": []
			},
			{
				"title": "Data Attributes",
				"url": "#data-attributes",
				"items": []
			}
		],
		"section": "Components",
		"slug": "components/legend",
		"slugFull": "/components/legend"
	},
	{
		"title": "Bits UI Select",
		"description": "How to use the Select component from Bits UI with Formsnap.",
		"path": "recipes/bits-ui-select",
		"content": "<script>\n\timport { Steps, Step, Callout } from \"@svecodocs/kit\"\n\timport LoadingCard from \"$lib/components/loading-card.svelte\"\n\timport BitsSelectForm from \"$lib/components/examples/bits-ui-select.svelte\"\n\timport BitsMultiSelectForm from \"$lib/components/examples/bits-ui-multi-select.svelte\"\n</script>\n<p>The <code>Select</code> component from <a href=\"https://bits-ui.com/docs/components/select\">Bits UI</a> is a simple, yet powerful component for building a custom select menu. It powers the <code>Select</code> component for <a href=\"https://shadcn-svelte.com/docs/components/select\">shadcn-svelte</a>, which is one of the most popular UI projects for Svelte. This recipe will demonstrate how to integrate that component with Formsnap.</p>\n<h2>Single Select</h2>\n<p>We're going to build a \"languages\" select menu that allows the user to select a single language from a list of pre-defined options. We'll use a code to represent the language's value, and the language's name as the label.</p>\n<steps>\n<p><step>Define the Schema</step></p>\n<p>Here's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the <code>+page.server.ts</code> file.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;schema.ts&#x22;\">import { z } from \"zod\";\n\nexport const languages = {\n\ten: \"English\",\n\tes: \"Spanish\",\n\tfr: \"French\",\n\tde: \"German\",\n\tit: \"Italian\",\n\tpt: \"Portuguese\",\n\tru: \"Russian\",\n\tzh: \"Chinese\",\n\tja: \"Japanese\",\n\tko: \"Korean\",\n} as const;\n\ntype Language = keyof typeof languages;\n\nexport const schema = z.object({\n\tlanguage: z.enum(Object.keys(languages) as [Language, ...Language[]]).default(\"en\"),\n});\n</code></pre>\n<p><step>Setup the Form</step></p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Select } from \"bits-ui\";\n\timport { Field, Control, Label, FieldErrors } from \"formsnap\";\n\timport { schema, languages } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData, enhance } = form;\n\n\tconst selectedLanguageLabel = $derived(\n\t\t$formData.language ? languages[$formData.language] : \"Select a language\"\n\t);\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:enhance>\n\t&#x3C;Field {form} name=\"language\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Language&#x3C;/Label>\n\t\t\t\t&#x3C;Select.Root type=\"single\" bind:value={$formData.language} name={props.name}>\n\t\t\t\t\t&#x3C;Select.Trigger {...props}>\n\t\t\t\t\t\t{selectedLabel}\n\t\t\t\t\t&#x3C;/Select.Trigger>\n\t\t\t\t\t&#x3C;Select.Content>\n\t\t\t\t\t\t{#each Object.entries(languages) as [value, label]}\n\t\t\t\t\t\t\t&#x3C;Select.Item {value}>\n\t\t\t\t\t\t\t\t{label}\n\t\t\t\t\t\t\t&#x3C;/Select.Item>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/Select.Content>\n\t\t\t\t&#x3C;/Select.Root>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>The docs will be translated to your preferred language.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>We apply the control <code>props</code> to the <code>Select.Trigger</code> component so that the label and other accessibility attributes are associated with it.</p>\n<p>We apply the <code>props.name</code> to the <code>Select.Root</code> component so a hidden input is rendered for the select.</p>\n<p><step>Finished Product</step></p>\n<p>That's it! 🎉</p>\n<p>With some additional styles and structure, the form could look something like this:</p>\n<bitsselectform>\n</bitsselectform></steps>\n<h2>Multiple Select</h2>\n<p>The <code>&#x3C;Select /></code> component also supports multiple selection. Here's how you can use it to build a multi-select form.</p>\n<steps>\n<p><step>Define the Schema</step></p>\n<p>Here's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the <code>+page.server.ts</code> file.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;schema.ts&#x22;\">import { z } from \"zod\";\n\nexport const colors = {\n\tblu: \"Blue\",\n\tred: \"Red\",\n\tgrn: \"Green\",\n\tylw: \"Yellow\",\n\tblk: \"Black\",\n} as const;\n\ntype Color = keyof typeof colors;\n\nexport const schema = z.object({\n\tcolors: z\n\t\t.array(z.enum(Object.keys(colors) as [Color, ...Color[]]))\n\t\t.min(1, \"Please select at least one color.\"),\n});\n</code></pre>\n<p><step>Setup the Form</step></p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Select } from \"bits-ui\";\n\timport { Field, Control, Label, FieldErrors } from \"formsnap\";\n\timport { schema, colors } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n\n\tconst selectedColors = $derived(\n\t\t$formData.colors.length ? $formData.colors.map((c) => colors[c]).join(\",\") : \"Select colors\"\n\t);\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:form.enhance>\n\t&#x3C;Field {form} name=\"colors\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;Label>Favorite colors&#x3C;/Label>\n\t\t\t\t&#x3C;Select.Root type=\"multiple\" bind:value={$formData.colors} name={props.name}>\n\t\t\t\t\t&#x3C;Select.Trigger {...props}>\n\t\t\t\t\t\t{selectedColors}\n\t\t\t\t\t&#x3C;/Select.Trigger>\n\t\t\t\t\t&#x3C;Select.Content>\n\t\t\t\t\t\t{#each Object.entries(colors) as [value, label]}\n\t\t\t\t\t\t\t&#x3C;Select.Item {value} {label} />\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/Select.Content>\n\t\t\t\t&#x3C;/Select.Root>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;Description>We'll use these colors to customize your experience.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>We apply the control <code>props</code> to the <code>Select.Trigger</code> component so that the label and other accessibility attributes are associated with it.</p>\n<p>We apply the <code>props.name</code> to the <code>Select.Root</code> component so a hidden input is rendered for the select.</p>\n<p><step>Finished Product</step></p>\n<p>That's it! 🎉</p>\n<p>With some additional styles and structure, the form could look something like this:</p>\n<bitsmultiselectform>\n</bitsmultiselectform></steps>",
		"raw": "<script>\n\timport { Steps, Step, Callout } from \"@svecodocs/kit\"\n\timport LoadingCard from \"$lib/components/loading-card.svelte\"\n\timport BitsSelectForm from \"$lib/components/examples/bits-ui-select.svelte\"\n\timport BitsMultiSelectForm from \"$lib/components/examples/bits-ui-multi-select.svelte\"\n</script>\n\nThe `Select` component from [Bits UI](https://bits-ui.com/docs/components/select) is a simple, yet powerful component for building a custom select menu. It powers the `Select` component for [shadcn-svelte](https://shadcn-svelte.com/docs/components/select), which is one of the most popular UI projects for Svelte. This recipe will demonstrate how to integrate that component with Formsnap.\n\n## Single Select\n\nWe're going to build a \"languages\" select menu that allows the user to select a single language from a list of pre-defined options. We'll use a code to represent the language's value, and the language's name as the label.\n\n<Steps>\n\n<Step>Define the Schema</Step>\n\nHere's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the `+page.server.ts` file.\n\n```ts title=\"schema.ts\"\nimport { z } from \"zod\";\n\nexport const languages = {\n\ten: \"English\",\n\tes: \"Spanish\",\n\tfr: \"French\",\n\tde: \"German\",\n\tit: \"Italian\",\n\tpt: \"Portuguese\",\n\tru: \"Russian\",\n\tzh: \"Chinese\",\n\tja: \"Japanese\",\n\tko: \"Korean\",\n} as const;\n\ntype Language = keyof typeof languages;\n\nexport const schema = z.object({\n\tlanguage: z.enum(Object.keys(languages) as [Language, ...Language[]]).default(\"en\"),\n});\n```\n\n<Step>Setup the Form</Step>\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Select } from \"bits-ui\";\n\timport { Field, Control, Label, FieldErrors } from \"formsnap\";\n\timport { schema, languages } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData, enhance } = form;\n\n\tconst selectedLanguageLabel = $derived(\n\t\t$formData.language ? languages[$formData.language] : \"Select a language\"\n\t);\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<Field {form} name=\"language\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Language</Label>\n\t\t\t\t<Select.Root type=\"single\" bind:value={$formData.language} name={props.name}>\n\t\t\t\t\t<Select.Trigger {...props}>\n\t\t\t\t\t\t{selectedLabel}\n\t\t\t\t\t</Select.Trigger>\n\t\t\t\t\t<Select.Content>\n\t\t\t\t\t\t{#each Object.entries(languages) as [value, label]}\n\t\t\t\t\t\t\t<Select.Item {value}>\n\t\t\t\t\t\t\t\t{label}\n\t\t\t\t\t\t\t</Select.Item>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</Select.Content>\n\t\t\t\t</Select.Root>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>The docs will be translated to your preferred language.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nWe apply the control `props` to the `Select.Trigger` component so that the label and other accessibility attributes are associated with it.\n\nWe apply the `props.name` to the `Select.Root` component so a hidden input is rendered for the select.\n\n<Step>Finished Product</Step>\n\nThat's it! 🎉\n\nWith some additional styles and structure, the form could look something like this:\n\n<BitsSelectForm />\n\n</Steps>\n\n## Multiple Select\n\nThe `<Select />` component also supports multiple selection. Here's how you can use it to build a multi-select form.\n\n<Steps>\n\n<Step>Define the Schema</Step>\n\nHere's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the `+page.server.ts` file.\n\n```ts title=\"schema.ts\"\nimport { z } from \"zod\";\n\nexport const colors = {\n\tblu: \"Blue\",\n\tred: \"Red\",\n\tgrn: \"Green\",\n\tylw: \"Yellow\",\n\tblk: \"Black\",\n} as const;\n\ntype Color = keyof typeof colors;\n\nexport const schema = z.object({\n\tcolors: z\n\t\t.array(z.enum(Object.keys(colors) as [Color, ...Color[]]))\n\t\t.min(1, \"Please select at least one color.\"),\n});\n```\n\n<Step>Setup the Form</Step>\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Select } from \"bits-ui\";\n\timport { Field, Control, Label, FieldErrors } from \"formsnap\";\n\timport { schema, colors } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n\n\tconst selectedColors = $derived(\n\t\t$formData.colors.length ? $formData.colors.map((c) => colors[c]).join(\",\") : \"Select colors\"\n\t);\n</script>\n\n<form method=\"POST\" use:form.enhance>\n\t<Field {form} name=\"colors\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<Label>Favorite colors</Label>\n\t\t\t\t<Select.Root type=\"multiple\" bind:value={$formData.colors} name={props.name}>\n\t\t\t\t\t<Select.Trigger {...props}>\n\t\t\t\t\t\t{selectedColors}\n\t\t\t\t\t</Select.Trigger>\n\t\t\t\t\t<Select.Content>\n\t\t\t\t\t\t{#each Object.entries(colors) as [value, label]}\n\t\t\t\t\t\t\t<Select.Item {value} {label} />\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</Select.Content>\n\t\t\t\t</Select.Root>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<Description>We'll use these colors to customize your experience.</Description>\n\t\t<FieldErrors />\n\t</Field>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nWe apply the control `props` to the `Select.Trigger` component so that the label and other accessibility attributes are associated with it.\n\nWe apply the `props.name` to the `Select.Root` component so a hidden input is rendered for the select.\n\n<Step>Finished Product</Step>\n\nThat's it! 🎉\n\nWith some additional styles and structure, the form could look something like this:\n\n<BitsMultiSelectForm />\n\n</Steps>",
		"toc": [
			{
				"title": "Single Select",
				"url": "#single-select",
				"items": []
			},
			{
				"title": "Multiple Select",
				"url": "#multiple-select",
				"items": []
			}
		],
		"section": "Recipes",
		"slug": "recipes/bits-ui-select",
		"slugFull": "/recipes/bits-ui-select"
	},
	{
		"title": "Checkbox Groups",
		"description": "Learn how to build checkbox group inputs with Formsnap.",
		"path": "recipes/checkbox-groups",
		"content": "<script>\n\timport { Steps, Step } from '@svecodocs/kit'\n\timport LoadingCard from '$lib/components/loading-card.svelte'\n\timport CheckboxGroup from '$lib/components/examples/checkbox-group.svelte'\n</script>\n<p>Checkbox groups are a set of checkboxes that allow users to select multiple options from a list, and are quite common in forms.</p>\n<p>In this guide, you'll learn how to build a checkbox group with Formsnap by building an \"Allergies\" checkbox group, where a user must select any food allergies they have. We'll start with very basic functionality and then look at more advanced refinements for validation.</p>\n<h2>Create a Checkbox Group</h2>\n<p>For the purposes of this guide, we'll assume you're using the <code>zod</code> and <code>zodClient</code> adapters from <a href=\"https://superforms.rocks\">Superforms</a>, but the same principles apply to all adapters.</p>\n<steps>\n<p><step>Define the Schema</step></p>\n<p>Let's start by defining a schema that contains an <code>array</code> to hold the selected options. We'll create this inside the <code>context=\"module\"</code> script tag of our Svelte component so we can access it in our component and <code>+page.server.ts</code> file.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\" context=\"module\">\n\timport { z } from \"zod\";\n\n\tconst allergies = [\"None\", \"Peanuts\", \"Shellfish\", \"Lactose\", \"Gluten\"] as const;\n\n\texport const schema = z.object({\n\t\tallergies: z\n\t\t\t.array(z.enum(allergies))\n\t\t\t.min(1, \"If you don't have any allergies, select 'None'.\"),\n\t});\n&#x3C;/script>\n</code></pre>\n<p>We've defined an array named <code>allergies</code> that holds the possible enum values, and then created a schema that requires at least one option to be selected.</p>\n<p><step>Setup the Load Function &#x26; Actions</step></p>\n<p>Next, we'll create a <code>+page.server.ts</code> file where we'll define our <code>load</code> function and <code>actions</code> to handle the form submission.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;+page.server.ts&#x22;\">import { superValidate } from \"sveltekit-superforms\";\nimport type { Actions, PageServerLoad } from \"./$types\";\nimport { schema } from \"./+page.svelte\";\nimport { zod } from \"sveltekit-superforms/adapters\";\nimport { fail } from \"@sveltejs/kit\";\n\nexport const load: PageServerLoad = async () => {\n\treturn {\n\t\tform: await superValidate(zod(schema)),\n\t};\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tconst form = await superValidate(event, zod(schema));\n\n\t\tif (!form.valid) {\n\t\t\treturn fail(400, { form });\n\t\t}\n\n\t\treturn { form };\n\t},\n};\n</code></pre>\n<p>Notice we're importing that schema we defined in our <code>+page.svelte</code> file and using it to validate the form data in the <code>load</code> function and <code>actions</code>.</p>\n<p><step>Initialize the SuperForm</step></p>\n<p>Now that we have our schema defined and our <code>load</code> function and <code>actions</code> set up, we can initialize the SuperForm in our Svelte component.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;!-- script context=\"module\" tag -->\n&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData } = form;\n&#x3C;/script>\n</code></pre>\n<p>We're using the <code>superForm</code> function to initialize the form, passing in the <code>form</code> object from our <code>load</code> function and the <code>zodClient</code> adapter to handle client-side validation.</p>\n<p><step>Import Components and Enhance the Form</step></p>\n<p>Now that our SuperForm is initialized, we can use it to construct our checkbox group.</p>\n<p>We'll first import the components we'll need from Formsnap, and then setup a <code>form</code> element with the <code>enhance</code> action to progressively enhance the form with client-side validation.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22; {5,15-18}\">&#x3C;!-- script context=\"module\" tag  -->\n&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Fieldset, Legend, Label, Control, FieldErrors, Description } from \"formsnap\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData } = form;\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:form.enhance>\n\t&#x3C;!-- ... -->\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Construct the Fieldset</step></p>\n<p>Since each checkbox in the group is related to a single field, we'll use a <code>Fieldset</code> component with a <code>Legend</code> to group them together. We'll use the <code>Description</code> component to provide more context about the fieldset and the <code>FieldErrors</code> component to display validation errors.</p>\n<pre><code class=\"language-svelte\" metastring=\"{3-8}\">&#x3C;!-- script tags -->\n&#x3C;form method=\"POST\" use:form.enhance>\n\t&#x3C;Fieldset {form} name=\"allergies\">\n\t\t&#x3C;Legend>Select your allergies&#x3C;/Legend>\n\t\t&#x3C;!-- ... -->\n\t\t&#x3C;Description>We'll accommodate your dietary restrictions.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>Next, we'll iterate over the <code>allergies</code> array and create a <a href=\"/docs/components/control\">Control</a> that includes a <a href=\"/docs/components/label\">Label</a> and a checkbox input for each option.</p>\n<pre><code class=\"language-svelte\" metastring=\"{5-17}\">&#x3C;!-- script tags -->\n&#x3C;form method=\"POST\" use:form.enhance>\n\t&#x3C;Fieldset {form} name=\"allergies\">\n\t\t&#x3C;Legend>Select your allergies&#x3C;/Legend>\n\t\t{#each allergies as allergy}\n\t\t\t&#x3C;Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t&#x3C;input\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\t\tvalue={allergy}\n\t\t\t\t\t/>\n\t\t\t\t\t&#x3C;Label>{value}&#x3C;/Label>\n\t\t\t\t{/snippet}\n\t\t\t&#x3C;/Control>\n\t\t{/each}\n\t\t&#x3C;Description>We'll accommodate your dietary restrictions.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Improve Validation</step></p>\n<p>We now have a functional checkbox group that allows users to select multiple options from a list. However, we can make some improvements to enhance the user experience and provide better validation feedback.</p>\n<p>You may have noticed that users can select <code>\"None\"</code> and another allergy at the same time, which doesn't make sense. We can address this by adding a refinement to our schema to ensure that if <code>\"None\"</code> is selected, no other allergies can be selected.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;  {10-12}\">&#x3C;script lang=\"ts\" context=\"module\">\n\timport { z } from \"zod\";\n\n\tconst allergies = [\"None\", \"Peanuts\", \"Shellfish\", \"Lactose\", \"Gluten\"] as const;\n\n\texport const schema = z.object({\n\t\tallergies: z\n\t\t\t.array(z.enum(allergies))\n\t\t\t.min(1, \"If you don't have any allergies, select 'None'.\")\n\t\t\t.refine((v) => {\n\t\t\t\treturn v.includes(\"None\") ? v.length === 1 : true;\n\t\t\t}, \"If you select 'None', you can't select any other allergies.\"),\n\t});\n&#x3C;/script>\n\n&#x3C;!-- ...rest -->\n</code></pre>\n<p>We've added a <code>refine</code> method to the <code>allergies</code> array to ensure that if <code>\"None\"</code> is selected, no other allergies can be selected. If the user selects <code>\"None\"</code>, the array length must be <code>1</code>, otherwise the validation will fail and the custom error message will be displayed.</p>\n<p><step>Finished Product</step></p>\n<p>That's it! You've successfully created a checkbox group with Formsnap. With some custom styles and components applied, the finished product might look something like this:</p>\n<checkboxgroup>\n</checkboxgroup></steps>\n<h2>TLDR - Show Me the Code</h2>\n<p>For those who prefer to skip the guide and get straight to the code, here's the code required to create a checkbox group with Formsnap.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;+page.server.ts&#x22;\">import { superValidate } from \"sveltekit-superforms\";\nimport type { Actions, PageServerLoad } from \"./$types\";\nimport { schema } from \"./+page.svelte\";\nimport { zod } from \"sveltekit-superforms/adapters\";\nimport { fail } from \"@sveltejs/kit\";\n\nexport const load: PageServerLoad = async () => {\n\treturn {\n\t\tform: await superValidate(zod(schema)),\n\t};\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tconst form = await superValidate(event, zod(schema));\n\n\t\tif (!form.valid) {\n\t\t\treturn fail(400, { form });\n\t\t}\n\n\t\treturn { form };\n\t},\n};\n</code></pre>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\" context=\"module\">\n\timport { z } from \"zod\";\n\n\texport const allergies = [\"None\", \"Peanuts\", \"Shellfish\", \"Lactose\", \"Gluten\"] as const;\n\n\texport const schema = z.object({\n\t\tallergies: z\n\t\t\t.array(z.enum(allergies))\n\t\t\t.min(1, \"If you don't have any allergies, select 'None'.\")\n\t\t\t.refine((v) => {\n\t\t\t\treturn v.includes(\"None\") ? v.length === 1 : true;\n\t\t\t}, \"If you select 'None', you can't select any other allergies.\"),\n\t});\n&#x3C;/script>\n\n&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Fieldset, Legend, Label, Control, FieldErrors, Description } from \"formsnap\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData } = form;\n&#x3C;/script>\n\n&#x3C;form method=\"POST\" use:form.enhance>\n\t&#x3C;Fieldset {form} name=\"allergies\">\n\t\t&#x3C;Legend>Select any allergies you may have&#x3C;/Legend>\n\t\t{#each allergies as allergy}\n\t\t\t&#x3C;Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t&#x3C;input\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\t\tvalue={allergy}\n\t\t\t\t\t/>\n\t\t\t\t\t&#x3C;Label>{allergy}&#x3C;/Label>\n\t\t\t\t{/snippet}\n\t\t\t&#x3C;/Control>\n\t\t{/each}\n\t\t&#x3C;Description>We'll accommodate your dietary restrictions.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>",
		"raw": "<script>\n\timport { Steps, Step } from '@svecodocs/kit'\n\timport LoadingCard from '$lib/components/loading-card.svelte'\n\timport CheckboxGroup from '$lib/components/examples/checkbox-group.svelte'\n</script>\n\nCheckbox groups are a set of checkboxes that allow users to select multiple options from a list, and are quite common in forms.\n\nIn this guide, you'll learn how to build a checkbox group with Formsnap by building an \"Allergies\" checkbox group, where a user must select any food allergies they have. We'll start with very basic functionality and then look at more advanced refinements for validation.\n\n## Create a Checkbox Group\n\nFor the purposes of this guide, we'll assume you're using the `zod` and `zodClient` adapters from [Superforms](https://superforms.rocks), but the same principles apply to all adapters.\n\n<Steps>\n\n<Step>Define the Schema</Step>\n\nLet's start by defining a schema that contains an `array` to hold the selected options. We'll create this inside the `context=\"module\"` script tag of our Svelte component so we can access it in our component and `+page.server.ts` file.\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\" context=\"module\">\n\timport { z } from \"zod\";\n\n\tconst allergies = [\"None\", \"Peanuts\", \"Shellfish\", \"Lactose\", \"Gluten\"] as const;\n\n\texport const schema = z.object({\n\t\tallergies: z\n\t\t\t.array(z.enum(allergies))\n\t\t\t.min(1, \"If you don't have any allergies, select 'None'.\"),\n\t});\n</script>\n```\n\nWe've defined an array named `allergies` that holds the possible enum values, and then created a schema that requires at least one option to be selected.\n\n<Step>Setup the Load Function & Actions</Step>\n\nNext, we'll create a `+page.server.ts` file where we'll define our `load` function and `actions` to handle the form submission.\n\n```ts title=\"+page.server.ts\"\nimport { superValidate } from \"sveltekit-superforms\";\nimport type { Actions, PageServerLoad } from \"./$types\";\nimport { schema } from \"./+page.svelte\";\nimport { zod } from \"sveltekit-superforms/adapters\";\nimport { fail } from \"@sveltejs/kit\";\n\nexport const load: PageServerLoad = async () => {\n\treturn {\n\t\tform: await superValidate(zod(schema)),\n\t};\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tconst form = await superValidate(event, zod(schema));\n\n\t\tif (!form.valid) {\n\t\t\treturn fail(400, { form });\n\t\t}\n\n\t\treturn { form };\n\t},\n};\n```\n\nNotice we're importing that schema we defined in our `+page.svelte` file and using it to validate the form data in the `load` function and `actions`.\n\n<Step>Initialize the SuperForm</Step>\n\nNow that we have our schema defined and our `load` function and `actions` set up, we can initialize the SuperForm in our Svelte component.\n\n```svelte title=\"+page.svelte\"\n<!-- script context=\"module\" tag -->\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport SuperDebug from \"sveltekit-superforms\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData } = form;\n</script>\n```\n\nWe're using the `superForm` function to initialize the form, passing in the `form` object from our `load` function and the `zodClient` adapter to handle client-side validation.\n\n<Step>Import Components and Enhance the Form</Step>\n\nNow that our SuperForm is initialized, we can use it to construct our checkbox group.\n\nWe'll first import the components we'll need from Formsnap, and then setup a `form` element with the `enhance` action to progressively enhance the form with client-side validation.\n\n```svelte title=\"+page.svelte\" {5,15-18}\n<!-- script context=\"module\" tag  -->\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Fieldset, Legend, Label, Control, FieldErrors, Description } from \"formsnap\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData } = form;\n</script>\n\n<form method=\"POST\" use:form.enhance>\n\t<!-- ... -->\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Construct the Fieldset</Step>\n\nSince each checkbox in the group is related to a single field, we'll use a `Fieldset` component with a `Legend` to group them together. We'll use the `Description` component to provide more context about the fieldset and the `FieldErrors` component to display validation errors.\n\n```svelte {3-8}\n<!-- script tags -->\n<form method=\"POST\" use:form.enhance>\n\t<Fieldset {form} name=\"allergies\">\n\t\t<Legend>Select your allergies</Legend>\n\t\t<!-- ... -->\n\t\t<Description>We'll accommodate your dietary restrictions.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nNext, we'll iterate over the `allergies` array and create a [Control](/docs/components/control) that includes a [Label](/docs/components/label) and a checkbox input for each option.\n\n```svelte {5-17}\n<!-- script tags -->\n<form method=\"POST\" use:form.enhance>\n\t<Fieldset {form} name=\"allergies\">\n\t\t<Legend>Select your allergies</Legend>\n\t\t{#each allergies as allergy}\n\t\t\t<Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\t\tvalue={allergy}\n\t\t\t\t\t/>\n\t\t\t\t\t<Label>{value}</Label>\n\t\t\t\t{/snippet}\n\t\t\t</Control>\n\t\t{/each}\n\t\t<Description>We'll accommodate your dietary restrictions.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Improve Validation</Step>\n\nWe now have a functional checkbox group that allows users to select multiple options from a list. However, we can make some improvements to enhance the user experience and provide better validation feedback.\n\nYou may have noticed that users can select `\"None\"` and another allergy at the same time, which doesn't make sense. We can address this by adding a refinement to our schema to ensure that if `\"None\"` is selected, no other allergies can be selected.\n\n```svelte title=\"+page.svelte\"  {10-12}\n<script lang=\"ts\" context=\"module\">\n\timport { z } from \"zod\";\n\n\tconst allergies = [\"None\", \"Peanuts\", \"Shellfish\", \"Lactose\", \"Gluten\"] as const;\n\n\texport const schema = z.object({\n\t\tallergies: z\n\t\t\t.array(z.enum(allergies))\n\t\t\t.min(1, \"If you don't have any allergies, select 'None'.\")\n\t\t\t.refine((v) => {\n\t\t\t\treturn v.includes(\"None\") ? v.length === 1 : true;\n\t\t\t}, \"If you select 'None', you can't select any other allergies.\"),\n\t});\n</script>\n\n<!-- ...rest -->\n```\n\nWe've added a `refine` method to the `allergies` array to ensure that if `\"None\"` is selected, no other allergies can be selected. If the user selects `\"None\"`, the array length must be `1`, otherwise the validation will fail and the custom error message will be displayed.\n\n<Step>Finished Product</Step>\n\nThat's it! You've successfully created a checkbox group with Formsnap. With some custom styles and components applied, the finished product might look something like this:\n\n<CheckboxGroup />\n\n</Steps>\n\n## TLDR - Show Me the Code\n\nFor those who prefer to skip the guide and get straight to the code, here's the code required to create a checkbox group with Formsnap.\n\n```ts title=\"+page.server.ts\"\nimport { superValidate } from \"sveltekit-superforms\";\nimport type { Actions, PageServerLoad } from \"./$types\";\nimport { schema } from \"./+page.svelte\";\nimport { zod } from \"sveltekit-superforms/adapters\";\nimport { fail } from \"@sveltejs/kit\";\n\nexport const load: PageServerLoad = async () => {\n\treturn {\n\t\tform: await superValidate(zod(schema)),\n\t};\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tconst form = await superValidate(event, zod(schema));\n\n\t\tif (!form.valid) {\n\t\t\treturn fail(400, { form });\n\t\t}\n\n\t\treturn { form };\n\t},\n};\n```\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\" context=\"module\">\n\timport { z } from \"zod\";\n\n\texport const allergies = [\"None\", \"Peanuts\", \"Shellfish\", \"Lactose\", \"Gluten\"] as const;\n\n\texport const schema = z.object({\n\t\tallergies: z\n\t\t\t.array(z.enum(allergies))\n\t\t\t.min(1, \"If you don't have any allergies, select 'None'.\")\n\t\t\t.refine((v) => {\n\t\t\t\treturn v.includes(\"None\") ? v.length === 1 : true;\n\t\t\t}, \"If you select 'None', you can't select any other allergies.\"),\n\t});\n</script>\n\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Fieldset, Legend, Label, Control, FieldErrors, Description } from \"formsnap\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data, {\n\t\tvalidators: zodClient(schema),\n\t});\n\tconst { form: formData } = form;\n</script>\n\n<form method=\"POST\" use:form.enhance>\n\t<Fieldset {form} name=\"allergies\">\n\t\t<Legend>Select any allergies you may have</Legend>\n\t\t{#each allergies as allergy}\n\t\t\t<Control>\n\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t{...props}\n\t\t\t\t\t\tbind:group={$formData.allergies}\n\t\t\t\t\t\tvalue={allergy}\n\t\t\t\t\t/>\n\t\t\t\t\t<Label>{allergy}</Label>\n\t\t\t\t{/snippet}\n\t\t\t</Control>\n\t\t{/each}\n\t\t<Description>We'll accommodate your dietary restrictions.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button type=\"submit\">Submit</button>\n</form>\n```",
		"toc": [
			{
				"title": "Create a Checkbox Group",
				"url": "#create-a-checkbox-group",
				"items": []
			},
			{
				"title": "TLDR - Show Me the Code",
				"url": "#tldr---show-me-the-code",
				"items": []
			}
		],
		"section": "Recipes",
		"slug": "recipes/checkbox-groups",
		"slugFull": "/recipes/checkbox-groups"
	},
	{
		"title": "Dynamic Fields",
		"description": "Learn how to creating dynamic fields by building a URLs field with Formsnap.",
		"path": "recipes/dynamic-fields",
		"content": "<script>\n\timport { Steps, Step, Callout } from '@svecodocs/kit'\n\timport LoadingCard from '$lib/components/loading-card.svelte'\n\timport DynamicFieldsForm from '$lib/components/examples/dynamic-fields.svelte'\n</script>\n<p>To create a dynamic field, you'll need to use the <a href=\"/docs/components/element-field\">ElementField</a> component, that allows you to treat each element of an array as it's own field.</p>\n<p>In this recipe, we'll create a URLs field where users can add and remove URLs from their profile.</p>\n<h2>Create Dynamic Fields</h2>\n<steps>\n<p><step>Define the Schema</step></p>\n<p>Here's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the <code>+page.server.ts</code> file.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;schema.ts&#x22;\">import { z } from \"zod\";\n\nexport const schema = z.object({\n\turls: z\n\t\t.array(z.string().url({ message: \"Please enter a valid URL.\" }))\n\t\t.min(2, \"You must include at least two URLs on your profile.\")\n\t\t.default([\"\", \"\"]),\n});\n</code></pre>\n<p>We've defined an array named <code>urls</code> that contains strings that must be valid URLs. We've also set a minimum length of 2 for the array itself, and provided two default values to start with. The minimum length of 2 may sounds strange, but we're only doing so to demonstrate different validation errors for the array and its elements.</p>\n<p><step>Create the Form</step></p>\n<p>We'll need to initialize our SuperForm with the form returned from the <code>load</code> function, and then setup the basic structure of our form.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n&#x3C;/script>\n\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;!-- ... -->\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Import the Components</step></p>\n<p>We have a few components we need to import to build the form.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;  {4-12}\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport {\n\t\tFieldset,\n\t\tLegend,\n\t\tElementField,\n\t\tControl,\n\t\tLabel,\n\t\tFieldErrors,\n\t\tDescription,\n\t} from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n&#x3C;/script>\n\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;!-- ... -->\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Scaffold the Fieldset</step></p>\n<p>Since our individual URL inputs will be part of the same field, we'll use a <a href=\"/docs/components/fieldset\">Fieldset</a> component to group them together and a <a href=\"/docs/components/legend\">Legend</a> to provide a title.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22; {3-8}\">&#x3C;!-- script tag -->\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;Fieldset {form} name=\"urls\">\n\t\t&#x3C;Legend>Public URLs&#x3C;/Legend>\n\t\t&#x3C;!-- ... -->\n\t\t&#x3C;Description>Add URLs to your profile that you'd like to share with others.&#x3C;/Description>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>The <a href=\"/docs/components/field-errors\">FieldErrors</a> component will display any validation errors for the array itself. In our case, it will display an error if the array doesn't contain at least two URLs (we'll add the errors for the individual URLs in the next step).</p>\n<p>The <a href=\"/docs/components/description\">Description</a> component will provide additional context about the fields once we've created them, but each field will share the same description from the <a href=\"/docs/components/fieldset\">Fieldset</a> scope.</p>\n<p><step>Render the URL Fields</step></p>\n<p>Now that we've scaffolded the <code>Fieldset</code>, we can iterate over the <code>$formData.urls</code> array to render the individual URL fields, which are represented by the <a href=\"/docs/components/element-field\">ElementField</a> component.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22; {5-18}\">&#x3C;!-- script tag -->\n&#x3C;form use:enhance method=\"POST\">\n\t&#x3C;Fieldset {form} name=\"urls\">\n\t\t&#x3C;Legend>Public URLs&#x3C;/Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t&#x3C;ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t&#x3C;Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t&#x3C;Label class=\"sr-only\">URL {i + 1}&#x3C;/Label>\n\t\t\t\t\t\t&#x3C;input type=\"url\" {...props} bind:value={$formData.urls[i]} />\n\t\t\t\t\t{/snippet}\n\t\t\t\t&#x3C;/Control>\n\t\t\t\t&#x3C;Description class=\"sr-only\">\n\t\t\t\t\tThis URL will be publicly available on your profile.\n\t\t\t\t&#x3C;/Description>\n\t\t\t\t&#x3C;FieldErrors />\n\t\t\t&#x3C;/ElementField>\n\t\t{/each}\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Fieldset>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>We're using the <code>ElementField</code> component to treat each element of the <code>urls</code> array as a separate field with its own state and validation. We're also using the <code>Control</code> component to create a label and input for each URL, and binding the input's value to the corresponding element of the <code>urls</code> array.</p>\n<callout type=\"tip\">\n<p>You should always include a label for each input for accessibility purposes. In this case, because we don't want to display a label visually for each input, we've added a class to the label to visually hide it while still making it available to screen readers.</p>\n</callout>\n<p><step>Make the Fields Dynamic</step></p>\n<p>At the moment, the user can only have two URLs in their profile. We want to allow them to add and remove URLs as needed. We can achieve this by adding buttons to add and remove URLs.</p>\n<pre><code class=\"language-svelte\" metastring=\"showLineNumbers title=&#x22;+page.svelte&#x22; {23-29,41-43,53}\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport {\n\t\tFieldset,\n\t\tLegend,\n\t\tElementField,\n\t\tControl,\n\t\tLabel,\n\t\tFieldErrors,\n\t\tDescription,\n\t} from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n\n\tfunction removeUrlByIndex(index: number) {\n\t\t$formData.urls = $formData.urls.filter((_, i) => i !== index);\n\t}\n\n\tfunction addUrl() {\n\t\t$formData.urls = [...$formData.urls, \"\"];\n\t}\n&#x3C;/script>\n\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;Fieldset {form} name=\"urls\">\n\t\t&#x3C;Legend>Public URLs&#x3C;/Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t&#x3C;ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t&#x3C;Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t&#x3C;Label class=\"sr-only\">URL {i + 1}&#x3C;/Label>\n\t\t\t\t\t\t&#x3C;input type=\"url\" {...props} bind:value={$formData.urls[i]} />\n\t\t\t\t\t\t&#x3C;button type=\"button\" onclick={() => removeUrlByIndex(i)}>\n\t\t\t\t\t\t\tRemove URL\n\t\t\t\t\t\t&#x3C;/button>\n\t\t\t\t\t{/snippet}\n\t\t\t\t&#x3C;/Control>\n\t\t\t\t&#x3C;Description class=\"sr-only\">\n\t\t\t\t\tThis URL will be publicly available on your profile.\n\t\t\t\t&#x3C;/Description>\n\t\t\t\t&#x3C;FieldErrors />\n\t\t\t&#x3C;/ElementField>\n\t\t{/each}\n\t\t&#x3C;FieldErrors />\n\t\t&#x3C;button type=\"button\" onclick={addUrl}>Add URL&#x3C;/button>\n\t&#x3C;/Fieldset>\n\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>We've added a <code>removeUrlByIndex</code> function that removes a URL from the <code>urls</code> array by its index, and a <code>addUrl</code> function that adds a new URL to the <code>urls</code> array. We've also added a button to remove each URL and a button to add a new URL.</p>\n<p>Now the user can add and remove URLs as needed, and the form will validate the array and its elements according to the schema we defined.</p>\n<p><step>Finished Product</step></p>\n<p>That's it! 🎉</p>\n<p>You've created a dynamic field that allows users to add and remove URLs from their profile. With some custom styles and finesse, you can make the form look something like this:</p>\n<dynamicfieldsform>\n</dynamicfieldsform></steps>\n<h2>TLDR - Show Me the Code</h2>\n<p>Here's the complete code for the form we built in this guide:</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;schema.ts&#x22;\">import { z } from \"zod\";\n\nexport const schema = z.object({\n\turls: z\n\t\t.array(z.string().url({ message: \"Please enter a valid URL.\" }))\n\t\t.min(2, \"You must include at least two URLs on your profile.\")\n\t\t.default([\"\", \"\"]),\n});\n</code></pre>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport {\n\t\tFieldset,\n\t\tLegend,\n\t\tElementField,\n\t\tControl,\n\t\tLabel,\n\t\tFieldErrors,\n\t\tDescription,\n\t} from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n\n\tfunction removeUrlByIndex(index: number) {\n\t\t$formData.urls = $formData.urls.filter((_, i) => i !== index);\n\t}\n\n\tfunction addUrl() {\n\t\t$formData.urls = [...$formData.urls, \"\"];\n\t}\n&#x3C;/script>\n\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;Fieldset {form} name=\"urls\">\n\t\t&#x3C;Legend>Public URLs&#x3C;/Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t&#x3C;ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t&#x3C;Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t&#x3C;Label class=\"sr-only\">URL {i + 1}&#x3C;/Label>\n\t\t\t\t\t\t&#x3C;input type=\"url\" {...props} bind:value={$formData.urls[i]} />\n\t\t\t\t\t\t&#x3C;button type=\"button\" onclick={() => removeUrlByIndex(i)}>\n\t\t\t\t\t\t\tRemove URL\n\t\t\t\t\t\t&#x3C;/button>\n\t\t\t\t\t{/snippet}\n\t\t\t\t&#x3C;/Control>\n\t\t\t\t&#x3C;Description class=\"sr-only\">\n\t\t\t\t\tThis URL will be publicly available on your profile.\n\t\t\t\t&#x3C;/Description>\n\t\t\t&#x3C;/ElementField>\n\t\t{/each}\n\t\t&#x3C;FieldErrors />\n\t\t&#x3C;button type=\"button\" onclick={addUrl}>Add URL&#x3C;/button>\n\t&#x3C;/Fieldset>\n\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>",
		"raw": "<script>\n\timport { Steps, Step, Callout } from '@svecodocs/kit'\n\timport LoadingCard from '$lib/components/loading-card.svelte'\n\timport DynamicFieldsForm from '$lib/components/examples/dynamic-fields.svelte'\n</script>\n\nTo create a dynamic field, you'll need to use the [ElementField](/docs/components/element-field) component, that allows you to treat each element of an array as it's own field.\n\nIn this recipe, we'll create a URLs field where users can add and remove URLs from their profile.\n\n## Create Dynamic Fields\n\n<Steps>\n\n<Step>Define the Schema</Step>\n\nHere's the schema we'll use for the form we'll build in this guide. We'll assume you know how to setup the load function and actions in the `+page.server.ts` file.\n\n```ts title=\"schema.ts\"\nimport { z } from \"zod\";\n\nexport const schema = z.object({\n\turls: z\n\t\t.array(z.string().url({ message: \"Please enter a valid URL.\" }))\n\t\t.min(2, \"You must include at least two URLs on your profile.\")\n\t\t.default([\"\", \"\"]),\n});\n```\n\nWe've defined an array named `urls` that contains strings that must be valid URLs. We've also set a minimum length of 2 for the array itself, and provided two default values to start with. The minimum length of 2 may sounds strange, but we're only doing so to demonstrate different validation errors for the array and its elements.\n\n<Step>Create the Form</Step>\n\nWe'll need to initialize our SuperForm with the form returned from the `load` function, and then setup the basic structure of our form.\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n</script>\n\n<form use:form.enhance method=\"POST\">\n\t<!-- ... -->\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Import the Components</Step>\n\nWe have a few components we need to import to build the form.\n\n```svelte title=\"+page.svelte\"  {4-12}\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport {\n\t\tFieldset,\n\t\tLegend,\n\t\tElementField,\n\t\tControl,\n\t\tLabel,\n\t\tFieldErrors,\n\t\tDescription,\n\t} from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n</script>\n\n<form use:form.enhance method=\"POST\">\n\t<!-- ... -->\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Scaffold the Fieldset</Step>\n\nSince our individual URL inputs will be part of the same field, we'll use a [Fieldset](/docs/components/fieldset) component to group them together and a [Legend](/docs/components/legend) to provide a title.\n\n```svelte title=\"+page.svelte\" {3-8}\n<!-- script tag -->\n<form use:form.enhance method=\"POST\">\n\t<Fieldset {form} name=\"urls\">\n\t\t<Legend>Public URLs</Legend>\n\t\t<!-- ... -->\n\t\t<Description>Add URLs to your profile that you'd like to share with others.</Description>\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nThe [FieldErrors](/docs/components/field-errors) component will display any validation errors for the array itself. In our case, it will display an error if the array doesn't contain at least two URLs (we'll add the errors for the individual URLs in the next step).\n\nThe [Description](/docs/components/description) component will provide additional context about the fields once we've created them, but each field will share the same description from the [Fieldset](/docs/components/fieldset) scope.\n\n<Step>Render the URL Fields</Step>\n\nNow that we've scaffolded the `Fieldset`, we can iterate over the `$formData.urls` array to render the individual URL fields, which are represented by the [ElementField](/docs/components/element-field) component.\n\n```svelte title=\"+page.svelte\" {5-18}\n<!-- script tag -->\n<form use:enhance method=\"POST\">\n\t<Fieldset {form} name=\"urls\">\n\t\t<Legend>Public URLs</Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t<ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t<Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t<Label class=\"sr-only\">URL {i + 1}</Label>\n\t\t\t\t\t\t<input type=\"url\" {...props} bind:value={$formData.urls[i]} />\n\t\t\t\t\t{/snippet}\n\t\t\t\t</Control>\n\t\t\t\t<Description class=\"sr-only\">\n\t\t\t\t\tThis URL will be publicly available on your profile.\n\t\t\t\t</Description>\n\t\t\t\t<FieldErrors />\n\t\t\t</ElementField>\n\t\t{/each}\n\t\t<FieldErrors />\n\t</Fieldset>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nWe're using the `ElementField` component to treat each element of the `urls` array as a separate field with its own state and validation. We're also using the `Control` component to create a label and input for each URL, and binding the input's value to the corresponding element of the `urls` array.\n\n<Callout type=\"tip\">\n\nYou should always include a label for each input for accessibility purposes. In this case, because we don't want to display a label visually for each input, we've added a class to the label to visually hide it while still making it available to screen readers.\n\n</Callout>\n\n<Step>Make the Fields Dynamic</Step>\n\nAt the moment, the user can only have two URLs in their profile. We want to allow them to add and remove URLs as needed. We can achieve this by adding buttons to add and remove URLs.\n\n```svelte showLineNumbers title=\"+page.svelte\" {23-29,41-43,53}\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport {\n\t\tFieldset,\n\t\tLegend,\n\t\tElementField,\n\t\tControl,\n\t\tLabel,\n\t\tFieldErrors,\n\t\tDescription,\n\t} from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n\n\tfunction removeUrlByIndex(index: number) {\n\t\t$formData.urls = $formData.urls.filter((_, i) => i !== index);\n\t}\n\n\tfunction addUrl() {\n\t\t$formData.urls = [...$formData.urls, \"\"];\n\t}\n</script>\n\n<form use:form.enhance method=\"POST\">\n\t<Fieldset {form} name=\"urls\">\n\t\t<Legend>Public URLs</Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t<ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t<Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t<Label class=\"sr-only\">URL {i + 1}</Label>\n\t\t\t\t\t\t<input type=\"url\" {...props} bind:value={$formData.urls[i]} />\n\t\t\t\t\t\t<button type=\"button\" onclick={() => removeUrlByIndex(i)}>\n\t\t\t\t\t\t\tRemove URL\n\t\t\t\t\t\t</button>\n\t\t\t\t\t{/snippet}\n\t\t\t\t</Control>\n\t\t\t\t<Description class=\"sr-only\">\n\t\t\t\t\tThis URL will be publicly available on your profile.\n\t\t\t\t</Description>\n\t\t\t\t<FieldErrors />\n\t\t\t</ElementField>\n\t\t{/each}\n\t\t<FieldErrors />\n\t\t<button type=\"button\" onclick={addUrl}>Add URL</button>\n\t</Fieldset>\n\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nWe've added a `removeUrlByIndex` function that removes a URL from the `urls` array by its index, and a `addUrl` function that adds a new URL to the `urls` array. We've also added a button to remove each URL and a button to add a new URL.\n\nNow the user can add and remove URLs as needed, and the form will validate the array and its elements according to the schema we defined.\n\n<Step>Finished Product</Step>\n\nThat's it! 🎉\n\nYou've created a dynamic field that allows users to add and remove URLs from their profile. With some custom styles and finesse, you can make the form look something like this:\n\n<DynamicFieldsForm  />\n\n</Steps>\n\n## TLDR - Show Me the Code\n\nHere's the complete code for the form we built in this guide:\n\n```ts title=\"schema.ts\"\nimport { z } from \"zod\";\n\nexport const schema = z.object({\n\turls: z\n\t\t.array(z.string().url({ message: \"Please enter a valid URL.\" }))\n\t\t.min(2, \"You must include at least two URLs on your profile.\")\n\t\t.default([\"\", \"\"]),\n});\n```\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport {\n\t\tFieldset,\n\t\tLegend,\n\t\tElementField,\n\t\tControl,\n\t\tLabel,\n\t\tFieldErrors,\n\t\tDescription,\n\t} from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n\n\tfunction removeUrlByIndex(index: number) {\n\t\t$formData.urls = $formData.urls.filter((_, i) => i !== index);\n\t}\n\n\tfunction addUrl() {\n\t\t$formData.urls = [...$formData.urls, \"\"];\n\t}\n</script>\n\n<form use:form.enhance method=\"POST\">\n\t<Fieldset {form} name=\"urls\">\n\t\t<Legend>Public URLs</Legend>\n\t\t{#each $formData.urls as _, i}\n\t\t\t<ElementField {form} name=\"urls[{i}]\">\n\t\t\t\t<Control>\n\t\t\t\t\t{#snippet children({ props })}\n\t\t\t\t\t\t<Label class=\"sr-only\">URL {i + 1}</Label>\n\t\t\t\t\t\t<input type=\"url\" {...props} bind:value={$formData.urls[i]} />\n\t\t\t\t\t\t<button type=\"button\" onclick={() => removeUrlByIndex(i)}>\n\t\t\t\t\t\t\tRemove URL\n\t\t\t\t\t\t</button>\n\t\t\t\t\t{/snippet}\n\t\t\t\t</Control>\n\t\t\t\t<Description class=\"sr-only\">\n\t\t\t\t\tThis URL will be publicly available on your profile.\n\t\t\t\t</Description>\n\t\t\t</ElementField>\n\t\t{/each}\n\t\t<FieldErrors />\n\t\t<button type=\"button\" onclick={addUrl}>Add URL</button>\n\t</Fieldset>\n\n\t<button type=\"submit\">Submit</button>\n</form>\n```",
		"toc": [
			{
				"title": "Create Dynamic Fields",
				"url": "#create-dynamic-fields",
				"items": []
			},
			{
				"title": "TLDR - Show Me the Code",
				"url": "#tldr---show-me-the-code",
				"items": []
			}
		],
		"section": "Recipes",
		"slug": "recipes/dynamic-fields",
		"slugFull": "/recipes/dynamic-fields"
	},
	{
		"title": "Multiple Select",
		"description": "Learn how to build multiple select inputs with Formsnap.",
		"path": "recipes/multiple-select",
		"content": "<script>\n\timport { Steps, Step } from \"@svecodocs/kit\"\n\timport LoadingCard from \"$lib/components/loading-card.svelte\"\n\timport MultipleSelectForm from \"$lib/components/examples/multiple-select.svelte\"\n</script>\n<p>In the following guide, you'll learn how to setup and validate multiple select fields with Formsnap by building an Ice Cream order form.</p>\n<h2>Building a Multiple Select Form</h2>\n<steps>\n<p><step>Define the Schema</step></p>\n<p>Here's the schema we'll use for the form we'll build in this guide. We're assuming you know how to setup the load function and actions, and have already created a <code>+page.svelte</code> and <code>+page.server.ts</code> file.</p>\n<pre><code class=\"language-ts\" metastring=\"title=&#x22;schema.ts&#x22;\">import { z } from \"zod\";\n\nexport const flavors = [\"vanilla\", \"chocolate\", \"cookies and cream\", \"strawberry\"] as const;\n\nexport const toppings = [\"sprinkles\", \"hot fudge\", \"whipped cream\", \"cherry\"] as const;\n\nexport const schema = z\n\t.object({\n\t\tscoops: z.number().min(1).default(1),\n\t\tflavors: z.array(z.enum(flavors)).min(1, \"You must select at least one flavor.\"),\n\t\ttoppings: z.array(z.enum(toppings)).max(2, \"You can only select up to two toppings.\"),\n\t})\n\t.refine((data) => (data.flavors.length > data.scoops ? false : true), {\n\t\tmessage: \"You can only select as many flavors as you have scoops.\",\n\t\tpath: [\"flavors\"],\n\t});\n</code></pre>\n<p>The schema represents an ice cream order form with a <code>scoops</code> field, a <code>flavors</code> field, and a <code>toppings</code> field. The <code>flavors</code> and <code>toppings</code> fields are arrays of enums, and we've added some custom validation to ensure the user can only select as many flavors as they have scoops. We've also set a minimum of 1 for the <code>flavors</code> field and a maximum of 2 for the <code>toppings</code> field.</p>\n<p><step>Create the Form</step></p>\n<p>Let's initialize our SuperForm with the form returned from the <code>load</code> function and setup the basic structure of our form. We'll also want to import the <code>schema</code>, <code>flavors</code>, and <code>toppings</code> from the schema file.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { schema, flavors, toppings } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n&#x3C;/script>\n\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;!-- ... -->\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Import the Components</step></p>\n<p>At a minimum we need to import the <a href=\"/docs/components/field\">Field</a>, <a href=\"/docs/components/control\">Control</a>, <a href=\"/docs/components/label\">Label</a>, and <a href=\"/docs/components/field-errors\">FieldErrors</a> components from Formsnap.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;  {4}\">&#x3C;script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Field, Control, Label, FieldErrors } from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n&#x3C;/script>\n\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;!-- ... -->\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Create the Scoops Field</step></p>\n<p>The first field we'll create is the <code>scoops</code> field, which will be a regular select input with a range of 1 to 5 scoops.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22; {3-19}\">&#x3C;!-- script tag -->\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;Field {form} name=\"scoops\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t&#x3C;Label>Number of scoops&#x3C;/Label>\n\t\t\t\t\t&#x3C;select {...props} bind:value={$formData.scoops}>\n\t\t\t\t\t\t{#each Array.from({ length: 5 }, (_, i) => i + 1) as num}\n\t\t\t\t\t\t\t&#x3C;option value={num}>\n\t\t\t\t\t\t\t\t{num === 1 ? `${num} Scoop` : `${num} Scoops`}\n\t\t\t\t\t\t\t&#x3C;/option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/select>\n\t\t\t\t&#x3C;/div>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Create the Flavors Field</step></p>\n<p>Next, let's create the <code>flavors</code> field. This field will be a multiple select input with the available flavors as options.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;  {20-36}\">&#x3C;!-- script tag -->\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;Field {form} name=\"scoops\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t&#x3C;Label>Number of scoops&#x3C;/Label>\n\t\t\t\t\t&#x3C;select {...props} bind:value={$formData.scoops}>\n\t\t\t\t\t\t{#each Array.from({ length: 5 }, (_, i) => i + 1) as num}\n\t\t\t\t\t\t\t&#x3C;option value={num}>\n\t\t\t\t\t\t\t\t{num === 1 ? `${num} Scoop` : `${num} Scoops`}\n\t\t\t\t\t\t\t&#x3C;/option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/select>\n\t\t\t\t&#x3C;/div>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"flavors\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t&#x3C;Label>What flavors do you fancy?&#x3C;/Label>\n\t\t\t\t\t&#x3C;select multiple bind:value={$formData.flavors} {...props}>\n\t\t\t\t\t\t{#each flavors as flavor}\n\t\t\t\t\t\t\t&#x3C;option value={flavor} selected={$formData.flavors.includes(flavor)}>\n\t\t\t\t\t\t\t\t{flavor}\n\t\t\t\t\t\t\t&#x3C;/option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/select>\n\t\t\t\t&#x3C;/div>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p>Notice that we're using the <code>multiple</code> attribute on the <code>select</code> element to allow the user to select multiple options. We're also using the <code>selected</code> attribute to pre-select the options that are already in the <code>formData.flavors</code> array.</p>\n<p><step>Create the Toppings Field</step></p>\n<p>Finally, let's create the <code>toppings</code> field. This field will also be a multiple select input with the available toppings as options.</p>\n<pre><code class=\"language-svelte\" metastring=\"title=&#x22;+page.svelte&#x22;  {37-53}\">&#x3C;!-- script tag -->\n&#x3C;form use:form.enhance method=\"POST\">\n\t&#x3C;Field {form} name=\"scoops\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t&#x3C;Label>Number of scoops&#x3C;/Label>\n\t\t\t\t\t&#x3C;select {...props} bind:value={$formData.scoops}>\n\t\t\t\t\t\t{#each Array.from({ length: 5 }, (_, i) => i + 1) as num}\n\t\t\t\t\t\t\t&#x3C;option value={num}>\n\t\t\t\t\t\t\t\t{num === 1 ? `${num} Scoop` : `${num} Scoops`}\n\t\t\t\t\t\t\t&#x3C;/option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/select>\n\t\t\t\t&#x3C;/div>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"flavors\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t&#x3C;Label>What flavors do you fancy?&#x3C;/Label>\n\t\t\t\t\t&#x3C;select multiple bind:value={$formData.flavors} {...props}>\n\t\t\t\t\t\t{#each flavors as flavor}\n\t\t\t\t\t\t\t&#x3C;option value={flavor} selected={$formData.flavors.includes(flavor)}>\n\t\t\t\t\t\t\t\t{flavor}\n\t\t\t\t\t\t\t&#x3C;/option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/select>\n\t\t\t\t&#x3C;/div>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;Field {form} name=\"toppings\">\n\t\t&#x3C;Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t&#x3C;div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t&#x3C;Label>Select your toppings&#x3C;/Label>\n\t\t\t\t\t&#x3C;select multiple bind:value={$formData.toppings} {...props}>\n\t\t\t\t\t\t{#each toppings as topping}\n\t\t\t\t\t\t\t&#x3C;option value={topping} selected={$formData.toppings.includes(topping)}>\n\t\t\t\t\t\t\t\t{topping}\n\t\t\t\t\t\t\t&#x3C;/option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t&#x3C;/select>\n\t\t\t\t&#x3C;/div>\n\t\t\t{/snippet}\n\t\t&#x3C;/Control>\n\t\t&#x3C;FieldErrors />\n\t&#x3C;/Field>\n\t&#x3C;button type=\"submit\">Submit&#x3C;/button>\n&#x3C;/form>\n</code></pre>\n<p><step>Finished Product</step></p>\n<p>That's it! 🎉</p>\n<p>You've created the functionality for a form containing multiple select inputs with validation. With some custom styles and finesse, you can make the form look something like this:</p>\n<multipleselectform>\n</multipleselectform></steps>",
		"raw": "<script>\n\timport { Steps, Step } from \"@svecodocs/kit\"\n\timport LoadingCard from \"$lib/components/loading-card.svelte\"\n\timport MultipleSelectForm from \"$lib/components/examples/multiple-select.svelte\"\n</script>\n\nIn the following guide, you'll learn how to setup and validate multiple select fields with Formsnap by building an Ice Cream order form.\n\n## Building a Multiple Select Form\n\n<Steps>\n\n<Step>Define the Schema</Step>\n\nHere's the schema we'll use for the form we'll build in this guide. We're assuming you know how to setup the load function and actions, and have already created a `+page.svelte` and `+page.server.ts` file.\n\n```ts title=\"schema.ts\"\nimport { z } from \"zod\";\n\nexport const flavors = [\"vanilla\", \"chocolate\", \"cookies and cream\", \"strawberry\"] as const;\n\nexport const toppings = [\"sprinkles\", \"hot fudge\", \"whipped cream\", \"cherry\"] as const;\n\nexport const schema = z\n\t.object({\n\t\tscoops: z.number().min(1).default(1),\n\t\tflavors: z.array(z.enum(flavors)).min(1, \"You must select at least one flavor.\"),\n\t\ttoppings: z.array(z.enum(toppings)).max(2, \"You can only select up to two toppings.\"),\n\t})\n\t.refine((data) => (data.flavors.length > data.scoops ? false : true), {\n\t\tmessage: \"You can only select as many flavors as you have scoops.\",\n\t\tpath: [\"flavors\"],\n\t});\n```\n\nThe schema represents an ice cream order form with a `scoops` field, a `flavors` field, and a `toppings` field. The `flavors` and `toppings` fields are arrays of enums, and we've added some custom validation to ensure the user can only select as many flavors as they have scoops. We've also set a minimum of 1 for the `flavors` field and a maximum of 2 for the `toppings` field.\n\n<Step>Create the Form</Step>\n\nLet's initialize our SuperForm with the form returned from the `load` function and setup the basic structure of our form. We'll also want to import the `schema`, `flavors`, and `toppings` from the schema file.\n\n```svelte title=\"+page.svelte\"\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { schema, flavors, toppings } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n</script>\n\n<form use:form.enhance method=\"POST\">\n\t<!-- ... -->\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Import the Components</Step>\n\nAt a minimum we need to import the [Field](/docs/components/field), [Control](/docs/components/control), [Label](/docs/components/label), and [FieldErrors](/docs/components/field-errors) components from Formsnap.\n\n```svelte title=\"+page.svelte\"  {4}\n<script lang=\"ts\">\n\timport { superForm } from \"sveltekit-superforms\";\n\timport { zodClient } from \"sveltekit-superforms/adapters\";\n\timport { Field, Control, Label, FieldErrors } from \"formsnap\";\n\timport { schema } from \"./schema.js\";\n\n\tlet { data } = $props();\n\n\tconst form = superForm(data.form, {\n\t\tvalidators: zodClient(schema),\n\t});\n\n\tconst { form: formData } = form;\n</script>\n\n<form use:form.enhance method=\"POST\">\n\t<!-- ... -->\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Create the Scoops Field</Step>\n\nThe first field we'll create is the `scoops` field, which will be a regular select input with a range of 1 to 5 scoops.\n\n```svelte title=\"+page.svelte\" {3-19}\n<!-- script tag -->\n<form use:form.enhance method=\"POST\">\n\t<Field {form} name=\"scoops\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t<Label>Number of scoops</Label>\n\t\t\t\t\t<select {...props} bind:value={$formData.scoops}>\n\t\t\t\t\t\t{#each Array.from({ length: 5 }, (_, i) => i + 1) as num}\n\t\t\t\t\t\t\t<option value={num}>\n\t\t\t\t\t\t\t\t{num === 1 ? `${num} Scoop` : `${num} Scoops`}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<FieldErrors />\n\t</Field>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Create the Flavors Field</Step>\n\nNext, let's create the `flavors` field. This field will be a multiple select input with the available flavors as options.\n\n```svelte title=\"+page.svelte\"  {20-36}\n<!-- script tag -->\n<form use:form.enhance method=\"POST\">\n\t<Field {form} name=\"scoops\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t<Label>Number of scoops</Label>\n\t\t\t\t\t<select {...props} bind:value={$formData.scoops}>\n\t\t\t\t\t\t{#each Array.from({ length: 5 }, (_, i) => i + 1) as num}\n\t\t\t\t\t\t\t<option value={num}>\n\t\t\t\t\t\t\t\t{num === 1 ? `${num} Scoop` : `${num} Scoops`}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"flavors\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t<Label>What flavors do you fancy?</Label>\n\t\t\t\t\t<select multiple bind:value={$formData.flavors} {...props}>\n\t\t\t\t\t\t{#each flavors as flavor}\n\t\t\t\t\t\t\t<option value={flavor} selected={$formData.flavors.includes(flavor)}>\n\t\t\t\t\t\t\t\t{flavor}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<FieldErrors />\n\t</Field>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\nNotice that we're using the `multiple` attribute on the `select` element to allow the user to select multiple options. We're also using the `selected` attribute to pre-select the options that are already in the `formData.flavors` array.\n\n<Step>Create the Toppings Field</Step>\n\nFinally, let's create the `toppings` field. This field will also be a multiple select input with the available toppings as options.\n\n```svelte title=\"+page.svelte\"  {37-53}\n<!-- script tag -->\n<form use:form.enhance method=\"POST\">\n\t<Field {form} name=\"scoops\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t<Label>Number of scoops</Label>\n\t\t\t\t\t<select {...props} bind:value={$formData.scoops}>\n\t\t\t\t\t\t{#each Array.from({ length: 5 }, (_, i) => i + 1) as num}\n\t\t\t\t\t\t\t<option value={num}>\n\t\t\t\t\t\t\t\t{num === 1 ? `${num} Scoop` : `${num} Scoops`}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"flavors\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t<Label>What flavors do you fancy?</Label>\n\t\t\t\t\t<select multiple bind:value={$formData.flavors} {...props}>\n\t\t\t\t\t\t{#each flavors as flavor}\n\t\t\t\t\t\t\t<option value={flavor} selected={$formData.flavors.includes(flavor)}>\n\t\t\t\t\t\t\t\t{flavor}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<FieldErrors />\n\t</Field>\n\t<Field {form} name=\"toppings\">\n\t\t<Control>\n\t\t\t{#snippet children({ props })}\n\t\t\t\t<div class=\"flex flex-col items-start gap-1\">\n\t\t\t\t\t<Label>Select your toppings</Label>\n\t\t\t\t\t<select multiple bind:value={$formData.toppings} {...props}>\n\t\t\t\t\t\t{#each toppings as topping}\n\t\t\t\t\t\t\t<option value={topping} selected={$formData.toppings.includes(topping)}>\n\t\t\t\t\t\t\t\t{topping}\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t</select>\n\t\t\t\t</div>\n\t\t\t{/snippet}\n\t\t</Control>\n\t\t<FieldErrors />\n\t</Field>\n\t<button type=\"submit\">Submit</button>\n</form>\n```\n\n<Step>Finished Product</Step>\n\nThat's it! 🎉\n\nYou've created the functionality for a form containing multiple select inputs with validation. With some custom styles and finesse, you can make the form look something like this:\n\n<MultipleSelectForm />\n\n</Steps>",
		"toc": [
			{
				"title": "Building a Multiple Select Form",
				"url": "#building-a-multiple-select-form",
				"items": []
			}
		],
		"section": "Recipes",
		"slug": "recipes/multiple-select",
		"slugFull": "/recipes/multiple-select"
	}
]
